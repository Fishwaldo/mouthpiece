/*
	MIT License

	Copyright (c) 2021 Justin Hammond

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
*/

// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"database/sql/driver"
	"errors"
	"fmt"
	"math"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/app"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/group"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/predicate"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/tenant"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/transportinstance"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/transportrecipient"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/user"
)

// TransportRecipientQuery is the builder for querying TransportRecipient entities.
type TransportRecipientQuery struct {
	config
	limit                 *int
	offset                *int
	unique                *bool
	order                 []OrderFunc
	fields                []string
	predicates            []predicate.TransportRecipient
	withTenant            *TenantQuery
	withTransportInstance *TransportInstanceQuery
	withAppRecipient      *AppQuery
	withGroupRecipient    *GroupQuery
	withUserRecipient     *UserQuery
	withFKs               bool
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the TransportRecipientQuery builder.
func (trq *TransportRecipientQuery) Where(ps ...predicate.TransportRecipient) *TransportRecipientQuery {
	trq.predicates = append(trq.predicates, ps...)
	return trq
}

// Limit adds a limit step to the query.
func (trq *TransportRecipientQuery) Limit(limit int) *TransportRecipientQuery {
	trq.limit = &limit
	return trq
}

// Offset adds an offset step to the query.
func (trq *TransportRecipientQuery) Offset(offset int) *TransportRecipientQuery {
	trq.offset = &offset
	return trq
}

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (trq *TransportRecipientQuery) Unique(unique bool) *TransportRecipientQuery {
	trq.unique = &unique
	return trq
}

// Order adds an order step to the query.
func (trq *TransportRecipientQuery) Order(o ...OrderFunc) *TransportRecipientQuery {
	trq.order = append(trq.order, o...)
	return trq
}

// QueryTenant chains the current query on the "tenant" edge.
func (trq *TransportRecipientQuery) QueryTenant() *TenantQuery {
	query := &TenantQuery{config: trq.config}
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := trq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := trq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(transportrecipient.Table, transportrecipient.FieldID, selector),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, transportrecipient.TenantTable, transportrecipient.TenantColumn),
		)
		fromU = sqlgraph.SetNeighbors(trq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryTransportInstance chains the current query on the "TransportInstance" edge.
func (trq *TransportRecipientQuery) QueryTransportInstance() *TransportInstanceQuery {
	query := &TransportInstanceQuery{config: trq.config}
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := trq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := trq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(transportrecipient.Table, transportrecipient.FieldID, selector),
			sqlgraph.To(transportinstance.Table, transportinstance.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, transportrecipient.TransportInstanceTable, transportrecipient.TransportInstanceColumn),
		)
		fromU = sqlgraph.SetNeighbors(trq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryAppRecipient chains the current query on the "AppRecipient" edge.
func (trq *TransportRecipientQuery) QueryAppRecipient() *AppQuery {
	query := &AppQuery{config: trq.config}
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := trq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := trq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(transportrecipient.Table, transportrecipient.FieldID, selector),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, transportrecipient.AppRecipientTable, transportrecipient.AppRecipientPrimaryKey...),
		)
		fromU = sqlgraph.SetNeighbors(trq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryGroupRecipient chains the current query on the "GroupRecipient" edge.
func (trq *TransportRecipientQuery) QueryGroupRecipient() *GroupQuery {
	query := &GroupQuery{config: trq.config}
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := trq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := trq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(transportrecipient.Table, transportrecipient.FieldID, selector),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, transportrecipient.GroupRecipientTable, transportrecipient.GroupRecipientPrimaryKey...),
		)
		fromU = sqlgraph.SetNeighbors(trq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryUserRecipient chains the current query on the "UserRecipient" edge.
func (trq *TransportRecipientQuery) QueryUserRecipient() *UserQuery {
	query := &UserQuery{config: trq.config}
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := trq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := trq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(transportrecipient.Table, transportrecipient.FieldID, selector),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, transportrecipient.UserRecipientTable, transportrecipient.UserRecipientPrimaryKey...),
		)
		fromU = sqlgraph.SetNeighbors(trq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// First returns the first TransportRecipient entity from the query.
// Returns a *NotFoundError when no TransportRecipient was found.
func (trq *TransportRecipientQuery) First(ctx context.Context) (*TransportRecipient, error) {
	nodes, err := trq.Limit(1).All(ctx)
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, &NotFoundError{transportrecipient.Label}
	}
	return nodes[0], nil
}

// FirstX is like First, but panics if an error occurs.
func (trq *TransportRecipientQuery) FirstX(ctx context.Context) *TransportRecipient {
	node, err := trq.First(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return node
}

// FirstID returns the first TransportRecipient ID from the query.
// Returns a *NotFoundError when no TransportRecipient ID was found.
func (trq *TransportRecipientQuery) FirstID(ctx context.Context) (id int, err error) {
	var ids []int
	if ids, err = trq.Limit(1).IDs(ctx); err != nil {
		return
	}
	if len(ids) == 0 {
		err = &NotFoundError{transportrecipient.Label}
		return
	}
	return ids[0], nil
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (trq *TransportRecipientQuery) FirstIDX(ctx context.Context) int {
	id, err := trq.FirstID(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return id
}

// Only returns a single TransportRecipient entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one TransportRecipient entity is found.
// Returns a *NotFoundError when no TransportRecipient entities are found.
func (trq *TransportRecipientQuery) Only(ctx context.Context) (*TransportRecipient, error) {
	nodes, err := trq.Limit(2).All(ctx)
	if err != nil {
		return nil, err
	}
	switch len(nodes) {
	case 1:
		return nodes[0], nil
	case 0:
		return nil, &NotFoundError{transportrecipient.Label}
	default:
		return nil, &NotSingularError{transportrecipient.Label}
	}
}

// OnlyX is like Only, but panics if an error occurs.
func (trq *TransportRecipientQuery) OnlyX(ctx context.Context) *TransportRecipient {
	node, err := trq.Only(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// OnlyID is like Only, but returns the only TransportRecipient ID in the query.
// Returns a *NotSingularError when more than one TransportRecipient ID is found.
// Returns a *NotFoundError when no entities are found.
func (trq *TransportRecipientQuery) OnlyID(ctx context.Context) (id int, err error) {
	var ids []int
	if ids, err = trq.Limit(2).IDs(ctx); err != nil {
		return
	}
	switch len(ids) {
	case 1:
		id = ids[0]
	case 0:
		err = &NotFoundError{transportrecipient.Label}
	default:
		err = &NotSingularError{transportrecipient.Label}
	}
	return
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (trq *TransportRecipientQuery) OnlyIDX(ctx context.Context) int {
	id, err := trq.OnlyID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// All executes the query and returns a list of TransportRecipients.
func (trq *TransportRecipientQuery) All(ctx context.Context) ([]*TransportRecipient, error) {
	if err := trq.prepareQuery(ctx); err != nil {
		return nil, err
	}
	return trq.sqlAll(ctx)
}

// AllX is like All, but panics if an error occurs.
func (trq *TransportRecipientQuery) AllX(ctx context.Context) []*TransportRecipient {
	nodes, err := trq.All(ctx)
	if err != nil {
		panic(err)
	}
	return nodes
}

// IDs executes the query and returns a list of TransportRecipient IDs.
func (trq *TransportRecipientQuery) IDs(ctx context.Context) ([]int, error) {
	var ids []int
	if err := trq.Select(transportrecipient.FieldID).Scan(ctx, &ids); err != nil {
		return nil, err
	}
	return ids, nil
}

// IDsX is like IDs, but panics if an error occurs.
func (trq *TransportRecipientQuery) IDsX(ctx context.Context) []int {
	ids, err := trq.IDs(ctx)
	if err != nil {
		panic(err)
	}
	return ids
}

// Count returns the count of the given query.
func (trq *TransportRecipientQuery) Count(ctx context.Context) (int, error) {
	if err := trq.prepareQuery(ctx); err != nil {
		return 0, err
	}
	return trq.sqlCount(ctx)
}

// CountX is like Count, but panics if an error occurs.
func (trq *TransportRecipientQuery) CountX(ctx context.Context) int {
	count, err := trq.Count(ctx)
	if err != nil {
		panic(err)
	}
	return count
}

// Exist returns true if the query has elements in the graph.
func (trq *TransportRecipientQuery) Exist(ctx context.Context) (bool, error) {
	if err := trq.prepareQuery(ctx); err != nil {
		return false, err
	}
	return trq.sqlExist(ctx)
}

// ExistX is like Exist, but panics if an error occurs.
func (trq *TransportRecipientQuery) ExistX(ctx context.Context) bool {
	exist, err := trq.Exist(ctx)
	if err != nil {
		panic(err)
	}
	return exist
}

// Clone returns a duplicate of the TransportRecipientQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (trq *TransportRecipientQuery) Clone() *TransportRecipientQuery {
	if trq == nil {
		return nil
	}
	return &TransportRecipientQuery{
		config:                trq.config,
		limit:                 trq.limit,
		offset:                trq.offset,
		order:                 append([]OrderFunc{}, trq.order...),
		predicates:            append([]predicate.TransportRecipient{}, trq.predicates...),
		withTenant:            trq.withTenant.Clone(),
		withTransportInstance: trq.withTransportInstance.Clone(),
		withAppRecipient:      trq.withAppRecipient.Clone(),
		withGroupRecipient:    trq.withGroupRecipient.Clone(),
		withUserRecipient:     trq.withUserRecipient.Clone(),
		// clone intermediate query.
		sql:    trq.sql.Clone(),
		path:   trq.path,
		unique: trq.unique,
	}
}

// WithTenant tells the query-builder to eager-load the nodes that are connected to
// the "tenant" edge. The optional arguments are used to configure the query builder of the edge.
func (trq *TransportRecipientQuery) WithTenant(opts ...func(*TenantQuery)) *TransportRecipientQuery {
	query := &TenantQuery{config: trq.config}
	for _, opt := range opts {
		opt(query)
	}
	trq.withTenant = query
	return trq
}

// WithTransportInstance tells the query-builder to eager-load the nodes that are connected to
// the "TransportInstance" edge. The optional arguments are used to configure the query builder of the edge.
func (trq *TransportRecipientQuery) WithTransportInstance(opts ...func(*TransportInstanceQuery)) *TransportRecipientQuery {
	query := &TransportInstanceQuery{config: trq.config}
	for _, opt := range opts {
		opt(query)
	}
	trq.withTransportInstance = query
	return trq
}

// WithAppRecipient tells the query-builder to eager-load the nodes that are connected to
// the "AppRecipient" edge. The optional arguments are used to configure the query builder of the edge.
func (trq *TransportRecipientQuery) WithAppRecipient(opts ...func(*AppQuery)) *TransportRecipientQuery {
	query := &AppQuery{config: trq.config}
	for _, opt := range opts {
		opt(query)
	}
	trq.withAppRecipient = query
	return trq
}

// WithGroupRecipient tells the query-builder to eager-load the nodes that are connected to
// the "GroupRecipient" edge. The optional arguments are used to configure the query builder of the edge.
func (trq *TransportRecipientQuery) WithGroupRecipient(opts ...func(*GroupQuery)) *TransportRecipientQuery {
	query := &GroupQuery{config: trq.config}
	for _, opt := range opts {
		opt(query)
	}
	trq.withGroupRecipient = query
	return trq
}

// WithUserRecipient tells the query-builder to eager-load the nodes that are connected to
// the "UserRecipient" edge. The optional arguments are used to configure the query builder of the edge.
func (trq *TransportRecipientQuery) WithUserRecipient(opts ...func(*UserQuery)) *TransportRecipientQuery {
	query := &UserQuery{config: trq.config}
	for _, opt := range opts {
		opt(query)
	}
	trq.withUserRecipient = query
	return trq
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//	var v []struct {
//		TenantID int `json:"tenant_id,omitempty"`
//		Count int `json:"count,omitempty"`
//	}
//
//	client.TransportRecipient.Query().
//		GroupBy(transportrecipient.FieldTenantID).
//		Aggregate(ent.Count()).
//		Scan(ctx, &v)
//
func (trq *TransportRecipientQuery) GroupBy(field string, fields ...string) *TransportRecipientGroupBy {
	grbuild := &TransportRecipientGroupBy{config: trq.config}
	grbuild.fields = append([]string{field}, fields...)
	grbuild.path = func(ctx context.Context) (prev *sql.Selector, err error) {
		if err := trq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		return trq.sqlQuery(ctx), nil
	}
	grbuild.label = transportrecipient.Label
	grbuild.flds, grbuild.scan = &grbuild.fields, grbuild.Scan
	return grbuild
}

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//	var v []struct {
//		TenantID int `json:"tenant_id,omitempty"`
//	}
//
//	client.TransportRecipient.Query().
//		Select(transportrecipient.FieldTenantID).
//		Scan(ctx, &v)
//
func (trq *TransportRecipientQuery) Select(fields ...string) *TransportRecipientSelect {
	trq.fields = append(trq.fields, fields...)
	selbuild := &TransportRecipientSelect{TransportRecipientQuery: trq}
	selbuild.label = transportrecipient.Label
	selbuild.flds, selbuild.scan = &trq.fields, selbuild.Scan
	return selbuild
}

func (trq *TransportRecipientQuery) prepareQuery(ctx context.Context) error {
	for _, f := range trq.fields {
		if !transportrecipient.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
		}
	}
	if trq.path != nil {
		prev, err := trq.path(ctx)
		if err != nil {
			return err
		}
		trq.sql = prev
	}
	if transportrecipient.Policy == nil {
		return errors.New("ent: uninitialized transportrecipient.Policy (forgotten import ent/runtime?)")
	}
	if err := transportrecipient.Policy.EvalQuery(ctx, trq); err != nil {
		return err
	}
	return nil
}

func (trq *TransportRecipientQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*TransportRecipient, error) {
	var (
		nodes       = []*TransportRecipient{}
		withFKs     = trq.withFKs
		_spec       = trq.querySpec()
		loadedTypes = [5]bool{
			trq.withTenant != nil,
			trq.withTransportInstance != nil,
			trq.withAppRecipient != nil,
			trq.withGroupRecipient != nil,
			trq.withUserRecipient != nil,
		}
	)
	if trq.withTenant != nil || trq.withTransportInstance != nil {
		withFKs = true
	}
	if withFKs {
		_spec.Node.Columns = append(_spec.Node.Columns, transportrecipient.ForeignKeys...)
	}
	_spec.ScanValues = func(columns []string) ([]any, error) {
		return (*TransportRecipient).scanValues(nil, columns)
	}
	_spec.Assign = func(columns []string, values []any) error {
		node := &TransportRecipient{config: trq.config}
		nodes = append(nodes, node)
		node.Edges.loadedTypes = loadedTypes
		return node.assignValues(columns, values)
	}
	for i := range hooks {
		hooks[i](ctx, _spec)
	}
	if err := sqlgraph.QueryNodes(ctx, trq.driver, _spec); err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nodes, nil
	}
	if query := trq.withTenant; query != nil {
		if err := trq.loadTenant(ctx, query, nodes, nil,
			func(n *TransportRecipient, e *Tenant) { n.Edges.Tenant = e }); err != nil {
			return nil, err
		}
	}
	if query := trq.withTransportInstance; query != nil {
		if err := trq.loadTransportInstance(ctx, query, nodes, nil,
			func(n *TransportRecipient, e *TransportInstance) { n.Edges.TransportInstance = e }); err != nil {
			return nil, err
		}
	}
	if query := trq.withAppRecipient; query != nil {
		if err := trq.loadAppRecipient(ctx, query, nodes,
			func(n *TransportRecipient) { n.Edges.AppRecipient = []*App{} },
			func(n *TransportRecipient, e *App) { n.Edges.AppRecipient = append(n.Edges.AppRecipient, e) }); err != nil {
			return nil, err
		}
	}
	if query := trq.withGroupRecipient; query != nil {
		if err := trq.loadGroupRecipient(ctx, query, nodes,
			func(n *TransportRecipient) { n.Edges.GroupRecipient = []*Group{} },
			func(n *TransportRecipient, e *Group) { n.Edges.GroupRecipient = append(n.Edges.GroupRecipient, e) }); err != nil {
			return nil, err
		}
	}
	if query := trq.withUserRecipient; query != nil {
		if err := trq.loadUserRecipient(ctx, query, nodes,
			func(n *TransportRecipient) { n.Edges.UserRecipient = []*User{} },
			func(n *TransportRecipient, e *User) { n.Edges.UserRecipient = append(n.Edges.UserRecipient, e) }); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

func (trq *TransportRecipientQuery) loadTenant(ctx context.Context, query *TenantQuery, nodes []*TransportRecipient, init func(*TransportRecipient), assign func(*TransportRecipient, *Tenant)) error {
	ids := make([]int, 0, len(nodes))
	nodeids := make(map[int][]*TransportRecipient)
	for i := range nodes {
		fk := nodes[i].TenantID
		if _, ok := nodeids[fk]; !ok {
			ids = append(ids, fk)
		}
		nodeids[fk] = append(nodeids[fk], nodes[i])
	}
	query.Where(tenant.IDIn(ids...))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nodeids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected foreign-key "tenant_id" returned %v`, n.ID)
		}
		for i := range nodes {
			assign(nodes[i], n)
		}
	}
	return nil
}
func (trq *TransportRecipientQuery) loadTransportInstance(ctx context.Context, query *TransportInstanceQuery, nodes []*TransportRecipient, init func(*TransportRecipient), assign func(*TransportRecipient, *TransportInstance)) error {
	ids := make([]int, 0, len(nodes))
	nodeids := make(map[int][]*TransportRecipient)
	for i := range nodes {
		if nodes[i].transport_instance_transport_recipients == nil {
			continue
		}
		fk := *nodes[i].transport_instance_transport_recipients
		if _, ok := nodeids[fk]; !ok {
			ids = append(ids, fk)
		}
		nodeids[fk] = append(nodeids[fk], nodes[i])
	}
	query.Where(transportinstance.IDIn(ids...))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nodeids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected foreign-key "transport_instance_transport_recipients" returned %v`, n.ID)
		}
		for i := range nodes {
			assign(nodes[i], n)
		}
	}
	return nil
}
func (trq *TransportRecipientQuery) loadAppRecipient(ctx context.Context, query *AppQuery, nodes []*TransportRecipient, init func(*TransportRecipient), assign func(*TransportRecipient, *App)) error {
	edgeIDs := make([]driver.Value, len(nodes))
	byID := make(map[int]*TransportRecipient)
	nids := make(map[int]map[*TransportRecipient]struct{})
	for i, node := range nodes {
		edgeIDs[i] = node.ID
		byID[node.ID] = node
		if init != nil {
			init(node)
		}
	}
	query.Where(func(s *sql.Selector) {
		joinT := sql.Table(transportrecipient.AppRecipientTable)
		s.Join(joinT).On(s.C(app.FieldID), joinT.C(transportrecipient.AppRecipientPrimaryKey[0]))
		s.Where(sql.InValues(joinT.C(transportrecipient.AppRecipientPrimaryKey[1]), edgeIDs...))
		columns := s.SelectedColumns()
		s.Select(joinT.C(transportrecipient.AppRecipientPrimaryKey[1]))
		s.AppendSelect(columns...)
		s.SetDistinct(false)
	})
	if err := query.prepareQuery(ctx); err != nil {
		return err
	}
	neighbors, err := query.sqlAll(ctx, func(_ context.Context, spec *sqlgraph.QuerySpec) {
		assign := spec.Assign
		values := spec.ScanValues
		spec.ScanValues = func(columns []string) ([]any, error) {
			values, err := values(columns[1:])
			if err != nil {
				return nil, err
			}
			return append([]any{new(sql.NullInt64)}, values...), nil
		}
		spec.Assign = func(columns []string, values []any) error {
			outValue := int(values[0].(*sql.NullInt64).Int64)
			inValue := int(values[1].(*sql.NullInt64).Int64)
			if nids[inValue] == nil {
				nids[inValue] = map[*TransportRecipient]struct{}{byID[outValue]: struct{}{}}
				return assign(columns[1:], values[1:])
			}
			nids[inValue][byID[outValue]] = struct{}{}
			return nil
		}
	})
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected "AppRecipient" node returned %v`, n.ID)
		}
		for kn := range nodes {
			assign(kn, n)
		}
	}
	return nil
}
func (trq *TransportRecipientQuery) loadGroupRecipient(ctx context.Context, query *GroupQuery, nodes []*TransportRecipient, init func(*TransportRecipient), assign func(*TransportRecipient, *Group)) error {
	edgeIDs := make([]driver.Value, len(nodes))
	byID := make(map[int]*TransportRecipient)
	nids := make(map[int]map[*TransportRecipient]struct{})
	for i, node := range nodes {
		edgeIDs[i] = node.ID
		byID[node.ID] = node
		if init != nil {
			init(node)
		}
	}
	query.Where(func(s *sql.Selector) {
		joinT := sql.Table(transportrecipient.GroupRecipientTable)
		s.Join(joinT).On(s.C(group.FieldID), joinT.C(transportrecipient.GroupRecipientPrimaryKey[0]))
		s.Where(sql.InValues(joinT.C(transportrecipient.GroupRecipientPrimaryKey[1]), edgeIDs...))
		columns := s.SelectedColumns()
		s.Select(joinT.C(transportrecipient.GroupRecipientPrimaryKey[1]))
		s.AppendSelect(columns...)
		s.SetDistinct(false)
	})
	if err := query.prepareQuery(ctx); err != nil {
		return err
	}
	neighbors, err := query.sqlAll(ctx, func(_ context.Context, spec *sqlgraph.QuerySpec) {
		assign := spec.Assign
		values := spec.ScanValues
		spec.ScanValues = func(columns []string) ([]any, error) {
			values, err := values(columns[1:])
			if err != nil {
				return nil, err
			}
			return append([]any{new(sql.NullInt64)}, values...), nil
		}
		spec.Assign = func(columns []string, values []any) error {
			outValue := int(values[0].(*sql.NullInt64).Int64)
			inValue := int(values[1].(*sql.NullInt64).Int64)
			if nids[inValue] == nil {
				nids[inValue] = map[*TransportRecipient]struct{}{byID[outValue]: struct{}{}}
				return assign(columns[1:], values[1:])
			}
			nids[inValue][byID[outValue]] = struct{}{}
			return nil
		}
	})
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected "GroupRecipient" node returned %v`, n.ID)
		}
		for kn := range nodes {
			assign(kn, n)
		}
	}
	return nil
}
func (trq *TransportRecipientQuery) loadUserRecipient(ctx context.Context, query *UserQuery, nodes []*TransportRecipient, init func(*TransportRecipient), assign func(*TransportRecipient, *User)) error {
	edgeIDs := make([]driver.Value, len(nodes))
	byID := make(map[int]*TransportRecipient)
	nids := make(map[int]map[*TransportRecipient]struct{})
	for i, node := range nodes {
		edgeIDs[i] = node.ID
		byID[node.ID] = node
		if init != nil {
			init(node)
		}
	}
	query.Where(func(s *sql.Selector) {
		joinT := sql.Table(transportrecipient.UserRecipientTable)
		s.Join(joinT).On(s.C(user.FieldID), joinT.C(transportrecipient.UserRecipientPrimaryKey[0]))
		s.Where(sql.InValues(joinT.C(transportrecipient.UserRecipientPrimaryKey[1]), edgeIDs...))
		columns := s.SelectedColumns()
		s.Select(joinT.C(transportrecipient.UserRecipientPrimaryKey[1]))
		s.AppendSelect(columns...)
		s.SetDistinct(false)
	})
	if err := query.prepareQuery(ctx); err != nil {
		return err
	}
	neighbors, err := query.sqlAll(ctx, func(_ context.Context, spec *sqlgraph.QuerySpec) {
		assign := spec.Assign
		values := spec.ScanValues
		spec.ScanValues = func(columns []string) ([]any, error) {
			values, err := values(columns[1:])
			if err != nil {
				return nil, err
			}
			return append([]any{new(sql.NullInt64)}, values...), nil
		}
		spec.Assign = func(columns []string, values []any) error {
			outValue := int(values[0].(*sql.NullInt64).Int64)
			inValue := int(values[1].(*sql.NullInt64).Int64)
			if nids[inValue] == nil {
				nids[inValue] = map[*TransportRecipient]struct{}{byID[outValue]: struct{}{}}
				return assign(columns[1:], values[1:])
			}
			nids[inValue][byID[outValue]] = struct{}{}
			return nil
		}
	})
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected "UserRecipient" node returned %v`, n.ID)
		}
		for kn := range nodes {
			assign(kn, n)
		}
	}
	return nil
}

func (trq *TransportRecipientQuery) sqlCount(ctx context.Context) (int, error) {
	_spec := trq.querySpec()
	_spec.Node.Columns = trq.fields
	if len(trq.fields) > 0 {
		_spec.Unique = trq.unique != nil && *trq.unique
	}
	return sqlgraph.CountNodes(ctx, trq.driver, _spec)
}

func (trq *TransportRecipientQuery) sqlExist(ctx context.Context) (bool, error) {
	switch _, err := trq.FirstID(ctx); {
	case IsNotFound(err):
		return false, nil
	case err != nil:
		return false, fmt.Errorf("ent: check existence: %w", err)
	default:
		return true, nil
	}
}

func (trq *TransportRecipientQuery) querySpec() *sqlgraph.QuerySpec {
	_spec := &sqlgraph.QuerySpec{
		Node: &sqlgraph.NodeSpec{
			Table:   transportrecipient.Table,
			Columns: transportrecipient.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: transportrecipient.FieldID,
			},
		},
		From:   trq.sql,
		Unique: true,
	}
	if unique := trq.unique; unique != nil {
		_spec.Unique = *unique
	}
	if fields := trq.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, transportrecipient.FieldID)
		for i := range fields {
			if fields[i] != transportrecipient.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, fields[i])
			}
		}
	}
	if ps := trq.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if limit := trq.limit; limit != nil {
		_spec.Limit = *limit
	}
	if offset := trq.offset; offset != nil {
		_spec.Offset = *offset
	}
	if ps := trq.order; len(ps) > 0 {
		_spec.Order = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return _spec
}

func (trq *TransportRecipientQuery) sqlQuery(ctx context.Context) *sql.Selector {
	builder := sql.Dialect(trq.driver.Dialect())
	t1 := builder.Table(transportrecipient.Table)
	columns := trq.fields
	if len(columns) == 0 {
		columns = transportrecipient.Columns
	}
	selector := builder.Select(t1.Columns(columns...)...).From(t1)
	if trq.sql != nil {
		selector = trq.sql
		selector.Select(selector.Columns(columns...)...)
	}
	if trq.unique != nil && *trq.unique {
		selector.Distinct()
	}
	for _, p := range trq.predicates {
		p(selector)
	}
	for _, p := range trq.order {
		p(selector)
	}
	if offset := trq.offset; offset != nil {
		// limit is mandatory for offset clause. We start
		// with default value, and override it below if needed.
		selector.Offset(*offset).Limit(math.MaxInt32)
	}
	if limit := trq.limit; limit != nil {
		selector.Limit(*limit)
	}
	return selector
}

// TransportRecipientGroupBy is the group-by builder for TransportRecipient entities.
type TransportRecipientGroupBy struct {
	config
	selector
	fields []string
	fns    []AggregateFunc
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Aggregate adds the given aggregation functions to the group-by query.
func (trgb *TransportRecipientGroupBy) Aggregate(fns ...AggregateFunc) *TransportRecipientGroupBy {
	trgb.fns = append(trgb.fns, fns...)
	return trgb
}

// Scan applies the group-by query and scans the result into the given value.
func (trgb *TransportRecipientGroupBy) Scan(ctx context.Context, v any) error {
	query, err := trgb.path(ctx)
	if err != nil {
		return err
	}
	trgb.sql = query
	return trgb.sqlScan(ctx, v)
}

func (trgb *TransportRecipientGroupBy) sqlScan(ctx context.Context, v any) error {
	for _, f := range trgb.fields {
		if !transportrecipient.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("invalid field %q for group-by", f)}
		}
	}
	selector := trgb.sqlQuery()
	if err := selector.Err(); err != nil {
		return err
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := trgb.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

func (trgb *TransportRecipientGroupBy) sqlQuery() *sql.Selector {
	selector := trgb.sql.Select()
	aggregation := make([]string, 0, len(trgb.fns))
	for _, fn := range trgb.fns {
		aggregation = append(aggregation, fn(selector))
	}
	// If no columns were selected in a custom aggregation function, the default
	// selection is the fields used for "group-by", and the aggregation functions.
	if len(selector.SelectedColumns()) == 0 {
		columns := make([]string, 0, len(trgb.fields)+len(trgb.fns))
		for _, f := range trgb.fields {
			columns = append(columns, selector.C(f))
		}
		columns = append(columns, aggregation...)
		selector.Select(columns...)
	}
	return selector.GroupBy(selector.Columns(trgb.fields...)...)
}

// TransportRecipientSelect is the builder for selecting fields of TransportRecipient entities.
type TransportRecipientSelect struct {
	*TransportRecipientQuery
	selector
	// intermediate query (i.e. traversal path).
	sql *sql.Selector
}

// Scan applies the selector query and scans the result into the given value.
func (trs *TransportRecipientSelect) Scan(ctx context.Context, v any) error {
	if err := trs.prepareQuery(ctx); err != nil {
		return err
	}
	trs.sql = trs.TransportRecipientQuery.sqlQuery(ctx)
	return trs.sqlScan(ctx, v)
}

func (trs *TransportRecipientSelect) sqlScan(ctx context.Context, v any) error {
	rows := &sql.Rows{}
	query, args := trs.sql.Query()
	if err := trs.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}
