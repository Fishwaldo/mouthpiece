/*
	MIT License

	Copyright (c) 2021 Justin Hammond

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
*/

// Code generated by entc, DO NOT EDIT.

package filter

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// TenantID applies equality check predicate on the "tenant_id" field. It's identical to TenantIDEQ.
func TenantID(v int) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTenantID), v))
	})
}

// Name applies equality check predicate on the "Name" field. It's identical to NameEQ.
func Name(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldName), v))
	})
}

// Description applies equality check predicate on the "Description" field. It's identical to DescriptionEQ.
func Description(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDescription), v))
	})
}

// Enabled applies equality check predicate on the "Enabled" field. It's identical to EnabledEQ.
func Enabled(v bool) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldEnabled), v))
	})
}

// FilterImpl applies equality check predicate on the "FilterImpl" field. It's identical to FilterImplEQ.
func FilterImpl(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFilterImpl), v))
	})
}

// TenantIDEQ applies the EQ predicate on the "tenant_id" field.
func TenantIDEQ(v int) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTenantID), v))
	})
}

// TenantIDNEQ applies the NEQ predicate on the "tenant_id" field.
func TenantIDNEQ(v int) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTenantID), v))
	})
}

// TenantIDIn applies the In predicate on the "tenant_id" field.
func TenantIDIn(vs ...int) predicate.Filter {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.In(s.C(FieldTenantID), v...))
	})
}

// TenantIDNotIn applies the NotIn predicate on the "tenant_id" field.
func TenantIDNotIn(vs ...int) predicate.Filter {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.NotIn(s.C(FieldTenantID), v...))
	})
}

// NameEQ applies the EQ predicate on the "Name" field.
func NameEQ(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldName), v))
	})
}

// NameNEQ applies the NEQ predicate on the "Name" field.
func NameNEQ(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldName), v))
	})
}

// NameIn applies the In predicate on the "Name" field.
func NameIn(vs ...string) predicate.Filter {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.In(s.C(FieldName), v...))
	})
}

// NameNotIn applies the NotIn predicate on the "Name" field.
func NameNotIn(vs ...string) predicate.Filter {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.NotIn(s.C(FieldName), v...))
	})
}

// NameGT applies the GT predicate on the "Name" field.
func NameGT(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldName), v))
	})
}

// NameGTE applies the GTE predicate on the "Name" field.
func NameGTE(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldName), v))
	})
}

// NameLT applies the LT predicate on the "Name" field.
func NameLT(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldName), v))
	})
}

// NameLTE applies the LTE predicate on the "Name" field.
func NameLTE(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldName), v))
	})
}

// NameContains applies the Contains predicate on the "Name" field.
func NameContains(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldName), v))
	})
}

// NameHasPrefix applies the HasPrefix predicate on the "Name" field.
func NameHasPrefix(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldName), v))
	})
}

// NameHasSuffix applies the HasSuffix predicate on the "Name" field.
func NameHasSuffix(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldName), v))
	})
}

// NameEqualFold applies the EqualFold predicate on the "Name" field.
func NameEqualFold(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldName), v))
	})
}

// NameContainsFold applies the ContainsFold predicate on the "Name" field.
func NameContainsFold(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldName), v))
	})
}

// DescriptionEQ applies the EQ predicate on the "Description" field.
func DescriptionEQ(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDescription), v))
	})
}

// DescriptionNEQ applies the NEQ predicate on the "Description" field.
func DescriptionNEQ(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDescription), v))
	})
}

// DescriptionIn applies the In predicate on the "Description" field.
func DescriptionIn(vs ...string) predicate.Filter {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.In(s.C(FieldDescription), v...))
	})
}

// DescriptionNotIn applies the NotIn predicate on the "Description" field.
func DescriptionNotIn(vs ...string) predicate.Filter {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.NotIn(s.C(FieldDescription), v...))
	})
}

// DescriptionGT applies the GT predicate on the "Description" field.
func DescriptionGT(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDescription), v))
	})
}

// DescriptionGTE applies the GTE predicate on the "Description" field.
func DescriptionGTE(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDescription), v))
	})
}

// DescriptionLT applies the LT predicate on the "Description" field.
func DescriptionLT(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDescription), v))
	})
}

// DescriptionLTE applies the LTE predicate on the "Description" field.
func DescriptionLTE(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDescription), v))
	})
}

// DescriptionContains applies the Contains predicate on the "Description" field.
func DescriptionContains(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldDescription), v))
	})
}

// DescriptionHasPrefix applies the HasPrefix predicate on the "Description" field.
func DescriptionHasPrefix(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldDescription), v))
	})
}

// DescriptionHasSuffix applies the HasSuffix predicate on the "Description" field.
func DescriptionHasSuffix(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldDescription), v))
	})
}

// DescriptionEqualFold applies the EqualFold predicate on the "Description" field.
func DescriptionEqualFold(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldDescription), v))
	})
}

// DescriptionContainsFold applies the ContainsFold predicate on the "Description" field.
func DescriptionContainsFold(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldDescription), v))
	})
}

// TypeEQ applies the EQ predicate on the "Type" field.
func TypeEQ(v Type) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldType), v))
	})
}

// TypeNEQ applies the NEQ predicate on the "Type" field.
func TypeNEQ(v Type) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldType), v))
	})
}

// TypeIn applies the In predicate on the "Type" field.
func TypeIn(vs ...Type) predicate.Filter {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.In(s.C(FieldType), v...))
	})
}

// TypeNotIn applies the NotIn predicate on the "Type" field.
func TypeNotIn(vs ...Type) predicate.Filter {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.NotIn(s.C(FieldType), v...))
	})
}

// EnabledEQ applies the EQ predicate on the "Enabled" field.
func EnabledEQ(v bool) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldEnabled), v))
	})
}

// EnabledNEQ applies the NEQ predicate on the "Enabled" field.
func EnabledNEQ(v bool) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldEnabled), v))
	})
}

// FilterImplEQ applies the EQ predicate on the "FilterImpl" field.
func FilterImplEQ(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFilterImpl), v))
	})
}

// FilterImplNEQ applies the NEQ predicate on the "FilterImpl" field.
func FilterImplNEQ(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFilterImpl), v))
	})
}

// FilterImplIn applies the In predicate on the "FilterImpl" field.
func FilterImplIn(vs ...string) predicate.Filter {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.In(s.C(FieldFilterImpl), v...))
	})
}

// FilterImplNotIn applies the NotIn predicate on the "FilterImpl" field.
func FilterImplNotIn(vs ...string) predicate.Filter {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.NotIn(s.C(FieldFilterImpl), v...))
	})
}

// FilterImplGT applies the GT predicate on the "FilterImpl" field.
func FilterImplGT(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFilterImpl), v))
	})
}

// FilterImplGTE applies the GTE predicate on the "FilterImpl" field.
func FilterImplGTE(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFilterImpl), v))
	})
}

// FilterImplLT applies the LT predicate on the "FilterImpl" field.
func FilterImplLT(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFilterImpl), v))
	})
}

// FilterImplLTE applies the LTE predicate on the "FilterImpl" field.
func FilterImplLTE(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFilterImpl), v))
	})
}

// FilterImplContains applies the Contains predicate on the "FilterImpl" field.
func FilterImplContains(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldFilterImpl), v))
	})
}

// FilterImplHasPrefix applies the HasPrefix predicate on the "FilterImpl" field.
func FilterImplHasPrefix(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldFilterImpl), v))
	})
}

// FilterImplHasSuffix applies the HasSuffix predicate on the "FilterImpl" field.
func FilterImplHasSuffix(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldFilterImpl), v))
	})
}

// FilterImplEqualFold applies the EqualFold predicate on the "FilterImpl" field.
func FilterImplEqualFold(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldFilterImpl), v))
	})
}

// FilterImplContainsFold applies the ContainsFold predicate on the "FilterImpl" field.
func FilterImplContainsFold(v string) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldFilterImpl), v))
	})
}

// HasTenant applies the HasEdge predicate on the "tenant" edge.
func HasTenant() predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(TenantTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, TenantTable, TenantColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasTenantWith applies the HasEdge predicate on the "tenant" edge with a given conditions (other predicates).
func HasTenantWith(preds ...predicate.Tenant) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(TenantInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, TenantTable, TenantColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasConfig applies the HasEdge predicate on the "config" edge.
func HasConfig() predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ConfigTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ConfigTable, ConfigColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasConfigWith applies the HasEdge predicate on the "config" edge with a given conditions (other predicates).
func HasConfigWith(preds ...predicate.FilterConfig) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ConfigInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ConfigTable, ConfigColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasGroups applies the HasEdge predicate on the "groups" edge.
func HasGroups() predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(GroupsTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, GroupsTable, GroupsPrimaryKey...),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasGroupsWith applies the HasEdge predicate on the "groups" edge with a given conditions (other predicates).
func HasGroupsWith(preds ...predicate.Group) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(GroupsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, GroupsTable, GroupsPrimaryKey...),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasApp applies the HasEdge predicate on the "app" edge.
func HasApp() predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AppTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, AppTable, AppPrimaryKey...),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAppWith applies the HasEdge predicate on the "app" edge with a given conditions (other predicates).
func HasAppWith(preds ...predicate.App) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AppInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, AppTable, AppPrimaryKey...),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasUser applies the HasEdge predicate on the "user" edge.
func HasUser() predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(UserTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, UserTable, UserPrimaryKey...),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasUserWith applies the HasEdge predicate on the "user" edge with a given conditions (other predicates).
func HasUserWith(preds ...predicate.User) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(UserInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, UserTable, UserPrimaryKey...),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Filter) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Filter) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Filter) predicate.Filter {
	return predicate.Filter(func(s *sql.Selector) {
		p(s.Not())
	})
}
