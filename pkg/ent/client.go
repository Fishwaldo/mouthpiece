/*
	MIT License

	Copyright (c) 2021 Justin Hammond

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
*/

// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/Fishwaldo/mouthpiece/pkg/ent/migrate"
	"github.com/google/uuid"

	"github.com/Fishwaldo/mouthpiece/pkg/ent/app"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/filter"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/filterconfig"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/group"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/message"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/msgvar"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/tenant"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/transportinstance"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/transportrecipient"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/user"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/usermetadata"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// App is the client for interacting with the App builders.
	App *AppClient
	// Filter is the client for interacting with the Filter builders.
	Filter *FilterClient
	// FilterConfig is the client for interacting with the FilterConfig builders.
	FilterConfig *FilterConfigClient
	// Group is the client for interacting with the Group builders.
	Group *GroupClient
	// Message is the client for interacting with the Message builders.
	Message *MessageClient
	// MsgVar is the client for interacting with the MsgVar builders.
	MsgVar *MsgVarClient
	// Tenant is the client for interacting with the Tenant builders.
	Tenant *TenantClient
	// TransportInstance is the client for interacting with the TransportInstance builders.
	TransportInstance *TransportInstanceClient
	// TransportRecipient is the client for interacting with the TransportRecipient builders.
	TransportRecipient *TransportRecipientClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserMetaData is the client for interacting with the UserMetaData builders.
	UserMetaData *UserMetaDataClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.App = NewAppClient(c.config)
	c.Filter = NewFilterClient(c.config)
	c.FilterConfig = NewFilterConfigClient(c.config)
	c.Group = NewGroupClient(c.config)
	c.Message = NewMessageClient(c.config)
	c.MsgVar = NewMsgVarClient(c.config)
	c.Tenant = NewTenantClient(c.config)
	c.TransportInstance = NewTransportInstanceClient(c.config)
	c.TransportRecipient = NewTransportRecipientClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserMetaData = NewUserMetaDataClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		App:                NewAppClient(cfg),
		Filter:             NewFilterClient(cfg),
		FilterConfig:       NewFilterConfigClient(cfg),
		Group:              NewGroupClient(cfg),
		Message:            NewMessageClient(cfg),
		MsgVar:             NewMsgVarClient(cfg),
		Tenant:             NewTenantClient(cfg),
		TransportInstance:  NewTransportInstanceClient(cfg),
		TransportRecipient: NewTransportRecipientClient(cfg),
		User:               NewUserClient(cfg),
		UserMetaData:       NewUserMetaDataClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		App:                NewAppClient(cfg),
		Filter:             NewFilterClient(cfg),
		FilterConfig:       NewFilterConfigClient(cfg),
		Group:              NewGroupClient(cfg),
		Message:            NewMessageClient(cfg),
		MsgVar:             NewMsgVarClient(cfg),
		Tenant:             NewTenantClient(cfg),
		TransportInstance:  NewTransportInstanceClient(cfg),
		TransportRecipient: NewTransportRecipientClient(cfg),
		User:               NewUserClient(cfg),
		UserMetaData:       NewUserMetaDataClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		App.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.App.Use(hooks...)
	c.Filter.Use(hooks...)
	c.FilterConfig.Use(hooks...)
	c.Group.Use(hooks...)
	c.Message.Use(hooks...)
	c.MsgVar.Use(hooks...)
	c.Tenant.Use(hooks...)
	c.TransportInstance.Use(hooks...)
	c.TransportRecipient.Use(hooks...)
	c.User.Use(hooks...)
	c.UserMetaData.Use(hooks...)
}

// AppClient is a client for the App schema.
type AppClient struct {
	config
}

// NewAppClient returns a client for the App from the given config.
func NewAppClient(c config) *AppClient {
	return &AppClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `app.Hooks(f(g(h())))`.
func (c *AppClient) Use(hooks ...Hook) {
	c.hooks.App = append(c.hooks.App, hooks...)
}

// Create returns a builder for creating a App entity.
func (c *AppClient) Create() *AppCreate {
	mutation := newAppMutation(c.config, OpCreate)
	return &AppCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of App entities.
func (c *AppClient) CreateBulk(builders ...*AppCreate) *AppCreateBulk {
	return &AppCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for App.
func (c *AppClient) Update() *AppUpdate {
	mutation := newAppMutation(c.config, OpUpdate)
	return &AppUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppClient) UpdateOne(a *App) *AppUpdateOne {
	mutation := newAppMutation(c.config, OpUpdateOne, withApp(a))
	return &AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppClient) UpdateOneID(id int) *AppUpdateOne {
	mutation := newAppMutation(c.config, OpUpdateOne, withAppID(id))
	return &AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for App.
func (c *AppClient) Delete() *AppDelete {
	mutation := newAppMutation(c.config, OpDelete)
	return &AppDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppClient) DeleteOne(a *App) *AppDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *AppClient) DeleteOneID(id int) *AppDeleteOne {
	builder := c.Delete().Where(app.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppDeleteOne{builder}
}

// Query returns a query builder for App.
func (c *AppClient) Query() *AppQuery {
	return &AppQuery{
		config: c.config,
	}
}

// Get returns a App entity by its id.
func (c *AppClient) Get(ctx context.Context, id int) (*App, error) {
	return c.Query().Where(app.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppClient) GetX(ctx context.Context, id int) *App {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a App.
func (c *AppClient) QueryTenant(a *App) *TenantQuery {
	query := &TenantQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, app.TenantTable, app.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMessages queries the messages edge of a App.
func (c *AppClient) QueryMessages(a *App) *MessageQuery {
	query := &MessageQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(message.Table, message.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, app.MessagesTable, app.MessagesColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFilters queries the filters edge of a App.
func (c *AppClient) QueryFilters(a *App) *FilterQuery {
	query := &FilterQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(filter.Table, filter.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, app.FiltersTable, app.FiltersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroups queries the groups edge of a App.
func (c *AppClient) QueryGroups(a *App) *GroupQuery {
	query := &GroupQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, app.GroupsTable, app.GroupsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTransportRecipients queries the TransportRecipients edge of a App.
func (c *AppClient) QueryTransportRecipients(a *App) *TransportRecipientQuery {
	query := &TransportRecipientQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(transportrecipient.Table, transportrecipient.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, app.TransportRecipientsTable, app.TransportRecipientsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AppClient) Hooks() []Hook {
	hooks := c.hooks.App
	return append(hooks[:len(hooks):len(hooks)], app.Hooks[:]...)
}

// FilterClient is a client for the Filter schema.
type FilterClient struct {
	config
}

// NewFilterClient returns a client for the Filter from the given config.
func NewFilterClient(c config) *FilterClient {
	return &FilterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `filter.Hooks(f(g(h())))`.
func (c *FilterClient) Use(hooks ...Hook) {
	c.hooks.Filter = append(c.hooks.Filter, hooks...)
}

// Create returns a builder for creating a Filter entity.
func (c *FilterClient) Create() *FilterCreate {
	mutation := newFilterMutation(c.config, OpCreate)
	return &FilterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Filter entities.
func (c *FilterClient) CreateBulk(builders ...*FilterCreate) *FilterCreateBulk {
	return &FilterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Filter.
func (c *FilterClient) Update() *FilterUpdate {
	mutation := newFilterMutation(c.config, OpUpdate)
	return &FilterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FilterClient) UpdateOne(f *Filter) *FilterUpdateOne {
	mutation := newFilterMutation(c.config, OpUpdateOne, withFilter(f))
	return &FilterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FilterClient) UpdateOneID(id int) *FilterUpdateOne {
	mutation := newFilterMutation(c.config, OpUpdateOne, withFilterID(id))
	return &FilterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Filter.
func (c *FilterClient) Delete() *FilterDelete {
	mutation := newFilterMutation(c.config, OpDelete)
	return &FilterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FilterClient) DeleteOne(f *Filter) *FilterDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *FilterClient) DeleteOneID(id int) *FilterDeleteOne {
	builder := c.Delete().Where(filter.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FilterDeleteOne{builder}
}

// Query returns a query builder for Filter.
func (c *FilterClient) Query() *FilterQuery {
	return &FilterQuery{
		config: c.config,
	}
}

// Get returns a Filter entity by its id.
func (c *FilterClient) Get(ctx context.Context, id int) (*Filter, error) {
	return c.Query().Where(filter.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FilterClient) GetX(ctx context.Context, id int) *Filter {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a Filter.
func (c *FilterClient) QueryTenant(f *Filter) *TenantQuery {
	query := &TenantQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(filter.Table, filter.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, filter.TenantTable, filter.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConfig queries the config edge of a Filter.
func (c *FilterClient) QueryConfig(f *Filter) *FilterConfigQuery {
	query := &FilterConfigQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(filter.Table, filter.FieldID, id),
			sqlgraph.To(filterconfig.Table, filterconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, filter.ConfigTable, filter.ConfigColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroups queries the groups edge of a Filter.
func (c *FilterClient) QueryGroups(f *Filter) *GroupQuery {
	query := &GroupQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(filter.Table, filter.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, filter.GroupsTable, filter.GroupsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApp queries the app edge of a Filter.
func (c *FilterClient) QueryApp(f *Filter) *AppQuery {
	query := &AppQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(filter.Table, filter.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, filter.AppTable, filter.AppPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Filter.
func (c *FilterClient) QueryUser(f *Filter) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(filter.Table, filter.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, filter.UserTable, filter.UserPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FilterClient) Hooks() []Hook {
	hooks := c.hooks.Filter
	return append(hooks[:len(hooks):len(hooks)], filter.Hooks[:]...)
}

// FilterConfigClient is a client for the FilterConfig schema.
type FilterConfigClient struct {
	config
}

// NewFilterConfigClient returns a client for the FilterConfig from the given config.
func NewFilterConfigClient(c config) *FilterConfigClient {
	return &FilterConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `filterconfig.Hooks(f(g(h())))`.
func (c *FilterConfigClient) Use(hooks ...Hook) {
	c.hooks.FilterConfig = append(c.hooks.FilterConfig, hooks...)
}

// Create returns a builder for creating a FilterConfig entity.
func (c *FilterConfigClient) Create() *FilterConfigCreate {
	mutation := newFilterConfigMutation(c.config, OpCreate)
	return &FilterConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FilterConfig entities.
func (c *FilterConfigClient) CreateBulk(builders ...*FilterConfigCreate) *FilterConfigCreateBulk {
	return &FilterConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FilterConfig.
func (c *FilterConfigClient) Update() *FilterConfigUpdate {
	mutation := newFilterConfigMutation(c.config, OpUpdate)
	return &FilterConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FilterConfigClient) UpdateOne(fc *FilterConfig) *FilterConfigUpdateOne {
	mutation := newFilterConfigMutation(c.config, OpUpdateOne, withFilterConfig(fc))
	return &FilterConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FilterConfigClient) UpdateOneID(id int) *FilterConfigUpdateOne {
	mutation := newFilterConfigMutation(c.config, OpUpdateOne, withFilterConfigID(id))
	return &FilterConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FilterConfig.
func (c *FilterConfigClient) Delete() *FilterConfigDelete {
	mutation := newFilterConfigMutation(c.config, OpDelete)
	return &FilterConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FilterConfigClient) DeleteOne(fc *FilterConfig) *FilterConfigDeleteOne {
	return c.DeleteOneID(fc.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *FilterConfigClient) DeleteOneID(id int) *FilterConfigDeleteOne {
	builder := c.Delete().Where(filterconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FilterConfigDeleteOne{builder}
}

// Query returns a query builder for FilterConfig.
func (c *FilterConfigClient) Query() *FilterConfigQuery {
	return &FilterConfigQuery{
		config: c.config,
	}
}

// Get returns a FilterConfig entity by its id.
func (c *FilterConfigClient) Get(ctx context.Context, id int) (*FilterConfig, error) {
	return c.Query().Where(filterconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FilterConfigClient) GetX(ctx context.Context, id int) *FilterConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a FilterConfig.
func (c *FilterConfigClient) QueryTenant(fc *FilterConfig) *TenantQuery {
	query := &TenantQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := fc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(filterconfig.Table, filterconfig.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, filterconfig.TenantTable, filterconfig.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(fc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFilter queries the filter edge of a FilterConfig.
func (c *FilterConfigClient) QueryFilter(fc *FilterConfig) *FilterQuery {
	query := &FilterQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := fc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(filterconfig.Table, filterconfig.FieldID, id),
			sqlgraph.To(filter.Table, filter.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, filterconfig.FilterTable, filterconfig.FilterColumn),
		)
		fromV = sqlgraph.Neighbors(fc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FilterConfigClient) Hooks() []Hook {
	hooks := c.hooks.FilterConfig
	return append(hooks[:len(hooks):len(hooks)], filterconfig.Hooks[:]...)
}

// GroupClient is a client for the Group schema.
type GroupClient struct {
	config
}

// NewGroupClient returns a client for the Group from the given config.
func NewGroupClient(c config) *GroupClient {
	return &GroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `group.Hooks(f(g(h())))`.
func (c *GroupClient) Use(hooks ...Hook) {
	c.hooks.Group = append(c.hooks.Group, hooks...)
}

// Create returns a builder for creating a Group entity.
func (c *GroupClient) Create() *GroupCreate {
	mutation := newGroupMutation(c.config, OpCreate)
	return &GroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Group entities.
func (c *GroupClient) CreateBulk(builders ...*GroupCreate) *GroupCreateBulk {
	return &GroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Group.
func (c *GroupClient) Update() *GroupUpdate {
	mutation := newGroupMutation(c.config, OpUpdate)
	return &GroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroupClient) UpdateOne(gr *Group) *GroupUpdateOne {
	mutation := newGroupMutation(c.config, OpUpdateOne, withGroup(gr))
	return &GroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroupClient) UpdateOneID(id int) *GroupUpdateOne {
	mutation := newGroupMutation(c.config, OpUpdateOne, withGroupID(id))
	return &GroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Group.
func (c *GroupClient) Delete() *GroupDelete {
	mutation := newGroupMutation(c.config, OpDelete)
	return &GroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GroupClient) DeleteOne(gr *Group) *GroupDeleteOne {
	return c.DeleteOneID(gr.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *GroupClient) DeleteOneID(id int) *GroupDeleteOne {
	builder := c.Delete().Where(group.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroupDeleteOne{builder}
}

// Query returns a query builder for Group.
func (c *GroupClient) Query() *GroupQuery {
	return &GroupQuery{
		config: c.config,
	}
}

// Get returns a Group entity by its id.
func (c *GroupClient) Get(ctx context.Context, id int) (*Group, error) {
	return c.Query().Where(group.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroupClient) GetX(ctx context.Context, id int) *Group {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a Group.
func (c *GroupClient) QueryTenant(gr *Group) *TenantQuery {
	query := &TenantQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := gr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, group.TenantTable, group.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(gr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTransportRecipients queries the TransportRecipients edge of a Group.
func (c *GroupClient) QueryTransportRecipients(gr *Group) *TransportRecipientQuery {
	query := &TransportRecipientQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := gr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(transportrecipient.Table, transportrecipient.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, group.TransportRecipientsTable, group.TransportRecipientsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(gr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a Group.
func (c *GroupClient) QueryUsers(gr *Group) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := gr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.UsersTable, group.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(gr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFilters queries the filters edge of a Group.
func (c *GroupClient) QueryFilters(gr *Group) *FilterQuery {
	query := &FilterQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := gr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(filter.Table, filter.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.FiltersTable, group.FiltersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(gr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApps queries the apps edge of a Group.
func (c *GroupClient) QueryApps(gr *Group) *AppQuery {
	query := &AppQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := gr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.AppsTable, group.AppsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(gr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GroupClient) Hooks() []Hook {
	hooks := c.hooks.Group
	return append(hooks[:len(hooks):len(hooks)], group.Hooks[:]...)
}

// MessageClient is a client for the Message schema.
type MessageClient struct {
	config
}

// NewMessageClient returns a client for the Message from the given config.
func NewMessageClient(c config) *MessageClient {
	return &MessageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `message.Hooks(f(g(h())))`.
func (c *MessageClient) Use(hooks ...Hook) {
	c.hooks.Message = append(c.hooks.Message, hooks...)
}

// Create returns a builder for creating a Message entity.
func (c *MessageClient) Create() *MessageCreate {
	mutation := newMessageMutation(c.config, OpCreate)
	return &MessageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Message entities.
func (c *MessageClient) CreateBulk(builders ...*MessageCreate) *MessageCreateBulk {
	return &MessageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Message.
func (c *MessageClient) Update() *MessageUpdate {
	mutation := newMessageMutation(c.config, OpUpdate)
	return &MessageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MessageClient) UpdateOne(m *Message) *MessageUpdateOne {
	mutation := newMessageMutation(c.config, OpUpdateOne, withMessage(m))
	return &MessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MessageClient) UpdateOneID(id uuid.UUID) *MessageUpdateOne {
	mutation := newMessageMutation(c.config, OpUpdateOne, withMessageID(id))
	return &MessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Message.
func (c *MessageClient) Delete() *MessageDelete {
	mutation := newMessageMutation(c.config, OpDelete)
	return &MessageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MessageClient) DeleteOne(m *Message) *MessageDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *MessageClient) DeleteOneID(id uuid.UUID) *MessageDeleteOne {
	builder := c.Delete().Where(message.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MessageDeleteOne{builder}
}

// Query returns a query builder for Message.
func (c *MessageClient) Query() *MessageQuery {
	return &MessageQuery{
		config: c.config,
	}
}

// Get returns a Message entity by its id.
func (c *MessageClient) Get(ctx context.Context, id uuid.UUID) (*Message, error) {
	return c.Query().Where(message.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MessageClient) GetX(ctx context.Context, id uuid.UUID) *Message {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a Message.
func (c *MessageClient) QueryTenant(m *Message) *TenantQuery {
	query := &TenantQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, message.TenantTable, message.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVars queries the vars edge of a Message.
func (c *MessageClient) QueryVars(m *Message) *MsgVarQuery {
	query := &MsgVarQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(msgvar.Table, msgvar.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, message.VarsTable, message.VarsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApp queries the app edge of a Message.
func (c *MessageClient) QueryApp(m *Message) *AppQuery {
	query := &AppQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, message.AppTable, message.AppColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MessageClient) Hooks() []Hook {
	hooks := c.hooks.Message
	return append(hooks[:len(hooks):len(hooks)], message.Hooks[:]...)
}

// MsgVarClient is a client for the MsgVar schema.
type MsgVarClient struct {
	config
}

// NewMsgVarClient returns a client for the MsgVar from the given config.
func NewMsgVarClient(c config) *MsgVarClient {
	return &MsgVarClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `msgvar.Hooks(f(g(h())))`.
func (c *MsgVarClient) Use(hooks ...Hook) {
	c.hooks.MsgVar = append(c.hooks.MsgVar, hooks...)
}

// Create returns a builder for creating a MsgVar entity.
func (c *MsgVarClient) Create() *MsgVarCreate {
	mutation := newMsgVarMutation(c.config, OpCreate)
	return &MsgVarCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MsgVar entities.
func (c *MsgVarClient) CreateBulk(builders ...*MsgVarCreate) *MsgVarCreateBulk {
	return &MsgVarCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MsgVar.
func (c *MsgVarClient) Update() *MsgVarUpdate {
	mutation := newMsgVarMutation(c.config, OpUpdate)
	return &MsgVarUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MsgVarClient) UpdateOne(mv *MsgVar) *MsgVarUpdateOne {
	mutation := newMsgVarMutation(c.config, OpUpdateOne, withMsgVar(mv))
	return &MsgVarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MsgVarClient) UpdateOneID(id int) *MsgVarUpdateOne {
	mutation := newMsgVarMutation(c.config, OpUpdateOne, withMsgVarID(id))
	return &MsgVarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MsgVar.
func (c *MsgVarClient) Delete() *MsgVarDelete {
	mutation := newMsgVarMutation(c.config, OpDelete)
	return &MsgVarDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MsgVarClient) DeleteOne(mv *MsgVar) *MsgVarDeleteOne {
	return c.DeleteOneID(mv.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *MsgVarClient) DeleteOneID(id int) *MsgVarDeleteOne {
	builder := c.Delete().Where(msgvar.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MsgVarDeleteOne{builder}
}

// Query returns a query builder for MsgVar.
func (c *MsgVarClient) Query() *MsgVarQuery {
	return &MsgVarQuery{
		config: c.config,
	}
}

// Get returns a MsgVar entity by its id.
func (c *MsgVarClient) Get(ctx context.Context, id int) (*MsgVar, error) {
	return c.Query().Where(msgvar.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MsgVarClient) GetX(ctx context.Context, id int) *MsgVar {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a MsgVar.
func (c *MsgVarClient) QueryTenant(mv *MsgVar) *TenantQuery {
	query := &TenantQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := mv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(msgvar.Table, msgvar.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, msgvar.TenantTable, msgvar.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(mv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwner queries the owner edge of a MsgVar.
func (c *MsgVarClient) QueryOwner(mv *MsgVar) *MessageQuery {
	query := &MessageQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := mv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(msgvar.Table, msgvar.FieldID, id),
			sqlgraph.To(message.Table, message.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, msgvar.OwnerTable, msgvar.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(mv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MsgVarClient) Hooks() []Hook {
	hooks := c.hooks.MsgVar
	return append(hooks[:len(hooks):len(hooks)], msgvar.Hooks[:]...)
}

// TenantClient is a client for the Tenant schema.
type TenantClient struct {
	config
}

// NewTenantClient returns a client for the Tenant from the given config.
func NewTenantClient(c config) *TenantClient {
	return &TenantClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tenant.Hooks(f(g(h())))`.
func (c *TenantClient) Use(hooks ...Hook) {
	c.hooks.Tenant = append(c.hooks.Tenant, hooks...)
}

// Create returns a builder for creating a Tenant entity.
func (c *TenantClient) Create() *TenantCreate {
	mutation := newTenantMutation(c.config, OpCreate)
	return &TenantCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Tenant entities.
func (c *TenantClient) CreateBulk(builders ...*TenantCreate) *TenantCreateBulk {
	return &TenantCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Tenant.
func (c *TenantClient) Update() *TenantUpdate {
	mutation := newTenantMutation(c.config, OpUpdate)
	return &TenantUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TenantClient) UpdateOne(t *Tenant) *TenantUpdateOne {
	mutation := newTenantMutation(c.config, OpUpdateOne, withTenant(t))
	return &TenantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TenantClient) UpdateOneID(id int) *TenantUpdateOne {
	mutation := newTenantMutation(c.config, OpUpdateOne, withTenantID(id))
	return &TenantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Tenant.
func (c *TenantClient) Delete() *TenantDelete {
	mutation := newTenantMutation(c.config, OpDelete)
	return &TenantDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TenantClient) DeleteOne(t *Tenant) *TenantDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *TenantClient) DeleteOneID(id int) *TenantDeleteOne {
	builder := c.Delete().Where(tenant.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TenantDeleteOne{builder}
}

// Query returns a query builder for Tenant.
func (c *TenantClient) Query() *TenantQuery {
	return &TenantQuery{
		config: c.config,
	}
}

// Get returns a Tenant entity by its id.
func (c *TenantClient) Get(ctx context.Context, id int) (*Tenant, error) {
	return c.Query().Where(tenant.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TenantClient) GetX(ctx context.Context, id int) *Tenant {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TenantClient) Hooks() []Hook {
	hooks := c.hooks.Tenant
	return append(hooks[:len(hooks):len(hooks)], tenant.Hooks[:]...)
}

// TransportInstanceClient is a client for the TransportInstance schema.
type TransportInstanceClient struct {
	config
}

// NewTransportInstanceClient returns a client for the TransportInstance from the given config.
func NewTransportInstanceClient(c config) *TransportInstanceClient {
	return &TransportInstanceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `transportinstance.Hooks(f(g(h())))`.
func (c *TransportInstanceClient) Use(hooks ...Hook) {
	c.hooks.TransportInstance = append(c.hooks.TransportInstance, hooks...)
}

// Create returns a builder for creating a TransportInstance entity.
func (c *TransportInstanceClient) Create() *TransportInstanceCreate {
	mutation := newTransportInstanceMutation(c.config, OpCreate)
	return &TransportInstanceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TransportInstance entities.
func (c *TransportInstanceClient) CreateBulk(builders ...*TransportInstanceCreate) *TransportInstanceCreateBulk {
	return &TransportInstanceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TransportInstance.
func (c *TransportInstanceClient) Update() *TransportInstanceUpdate {
	mutation := newTransportInstanceMutation(c.config, OpUpdate)
	return &TransportInstanceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TransportInstanceClient) UpdateOne(ti *TransportInstance) *TransportInstanceUpdateOne {
	mutation := newTransportInstanceMutation(c.config, OpUpdateOne, withTransportInstance(ti))
	return &TransportInstanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TransportInstanceClient) UpdateOneID(id int) *TransportInstanceUpdateOne {
	mutation := newTransportInstanceMutation(c.config, OpUpdateOne, withTransportInstanceID(id))
	return &TransportInstanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TransportInstance.
func (c *TransportInstanceClient) Delete() *TransportInstanceDelete {
	mutation := newTransportInstanceMutation(c.config, OpDelete)
	return &TransportInstanceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TransportInstanceClient) DeleteOne(ti *TransportInstance) *TransportInstanceDeleteOne {
	return c.DeleteOneID(ti.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *TransportInstanceClient) DeleteOneID(id int) *TransportInstanceDeleteOne {
	builder := c.Delete().Where(transportinstance.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TransportInstanceDeleteOne{builder}
}

// Query returns a query builder for TransportInstance.
func (c *TransportInstanceClient) Query() *TransportInstanceQuery {
	return &TransportInstanceQuery{
		config: c.config,
	}
}

// Get returns a TransportInstance entity by its id.
func (c *TransportInstanceClient) Get(ctx context.Context, id int) (*TransportInstance, error) {
	return c.Query().Where(transportinstance.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TransportInstanceClient) GetX(ctx context.Context, id int) *TransportInstance {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a TransportInstance.
func (c *TransportInstanceClient) QueryTenant(ti *TransportInstance) *TenantQuery {
	query := &TenantQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ti.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transportinstance.Table, transportinstance.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, transportinstance.TenantTable, transportinstance.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(ti.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTransportRecipients queries the TransportRecipients edge of a TransportInstance.
func (c *TransportInstanceClient) QueryTransportRecipients(ti *TransportInstance) *TransportRecipientQuery {
	query := &TransportRecipientQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ti.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transportinstance.Table, transportinstance.FieldID, id),
			sqlgraph.To(transportrecipient.Table, transportrecipient.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, transportinstance.TransportRecipientsTable, transportinstance.TransportRecipientsColumn),
		)
		fromV = sqlgraph.Neighbors(ti.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TransportInstanceClient) Hooks() []Hook {
	hooks := c.hooks.TransportInstance
	return append(hooks[:len(hooks):len(hooks)], transportinstance.Hooks[:]...)
}

// TransportRecipientClient is a client for the TransportRecipient schema.
type TransportRecipientClient struct {
	config
}

// NewTransportRecipientClient returns a client for the TransportRecipient from the given config.
func NewTransportRecipientClient(c config) *TransportRecipientClient {
	return &TransportRecipientClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `transportrecipient.Hooks(f(g(h())))`.
func (c *TransportRecipientClient) Use(hooks ...Hook) {
	c.hooks.TransportRecipient = append(c.hooks.TransportRecipient, hooks...)
}

// Create returns a builder for creating a TransportRecipient entity.
func (c *TransportRecipientClient) Create() *TransportRecipientCreate {
	mutation := newTransportRecipientMutation(c.config, OpCreate)
	return &TransportRecipientCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TransportRecipient entities.
func (c *TransportRecipientClient) CreateBulk(builders ...*TransportRecipientCreate) *TransportRecipientCreateBulk {
	return &TransportRecipientCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TransportRecipient.
func (c *TransportRecipientClient) Update() *TransportRecipientUpdate {
	mutation := newTransportRecipientMutation(c.config, OpUpdate)
	return &TransportRecipientUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TransportRecipientClient) UpdateOne(tr *TransportRecipient) *TransportRecipientUpdateOne {
	mutation := newTransportRecipientMutation(c.config, OpUpdateOne, withTransportRecipient(tr))
	return &TransportRecipientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TransportRecipientClient) UpdateOneID(id int) *TransportRecipientUpdateOne {
	mutation := newTransportRecipientMutation(c.config, OpUpdateOne, withTransportRecipientID(id))
	return &TransportRecipientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TransportRecipient.
func (c *TransportRecipientClient) Delete() *TransportRecipientDelete {
	mutation := newTransportRecipientMutation(c.config, OpDelete)
	return &TransportRecipientDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TransportRecipientClient) DeleteOne(tr *TransportRecipient) *TransportRecipientDeleteOne {
	return c.DeleteOneID(tr.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *TransportRecipientClient) DeleteOneID(id int) *TransportRecipientDeleteOne {
	builder := c.Delete().Where(transportrecipient.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TransportRecipientDeleteOne{builder}
}

// Query returns a query builder for TransportRecipient.
func (c *TransportRecipientClient) Query() *TransportRecipientQuery {
	return &TransportRecipientQuery{
		config: c.config,
	}
}

// Get returns a TransportRecipient entity by its id.
func (c *TransportRecipientClient) Get(ctx context.Context, id int) (*TransportRecipient, error) {
	return c.Query().Where(transportrecipient.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TransportRecipientClient) GetX(ctx context.Context, id int) *TransportRecipient {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a TransportRecipient.
func (c *TransportRecipientClient) QueryTenant(tr *TransportRecipient) *TenantQuery {
	query := &TenantQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := tr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transportrecipient.Table, transportrecipient.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, transportrecipient.TenantTable, transportrecipient.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(tr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTransportInstance queries the TransportInstance edge of a TransportRecipient.
func (c *TransportRecipientClient) QueryTransportInstance(tr *TransportRecipient) *TransportInstanceQuery {
	query := &TransportInstanceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := tr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transportrecipient.Table, transportrecipient.FieldID, id),
			sqlgraph.To(transportinstance.Table, transportinstance.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, transportrecipient.TransportInstanceTable, transportrecipient.TransportInstanceColumn),
		)
		fromV = sqlgraph.Neighbors(tr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAppRecipient queries the AppRecipient edge of a TransportRecipient.
func (c *TransportRecipientClient) QueryAppRecipient(tr *TransportRecipient) *AppQuery {
	query := &AppQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := tr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transportrecipient.Table, transportrecipient.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, transportrecipient.AppRecipientTable, transportrecipient.AppRecipientPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(tr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroupRecipient queries the GroupRecipient edge of a TransportRecipient.
func (c *TransportRecipientClient) QueryGroupRecipient(tr *TransportRecipient) *GroupQuery {
	query := &GroupQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := tr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transportrecipient.Table, transportrecipient.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, transportrecipient.GroupRecipientTable, transportrecipient.GroupRecipientPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(tr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserRecipient queries the UserRecipient edge of a TransportRecipient.
func (c *TransportRecipientClient) QueryUserRecipient(tr *TransportRecipient) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := tr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transportrecipient.Table, transportrecipient.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, transportrecipient.UserRecipientTable, transportrecipient.UserRecipientPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(tr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TransportRecipientClient) Hooks() []Hook {
	hooks := c.hooks.TransportRecipient
	return append(hooks[:len(hooks):len(hooks)], transportrecipient.Hooks[:]...)
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a User.
func (c *UserClient) QueryTenant(u *User) *TenantQuery {
	query := &TenantQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, user.TenantTable, user.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMetadata queries the metadata edge of a User.
func (c *UserClient) QueryMetadata(u *User) *UserMetaDataQuery {
	query := &UserMetaDataQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(usermetadata.Table, usermetadata.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MetadataTable, user.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFilters queries the filters edge of a User.
func (c *UserClient) QueryFilters(u *User) *FilterQuery {
	query := &FilterQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(filter.Table, filter.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.FiltersTable, user.FiltersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroups queries the groups edge of a User.
func (c *UserClient) QueryGroups(u *User) *GroupQuery {
	query := &GroupQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.GroupsTable, user.GroupsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTransportRecipients queries the TransportRecipients edge of a User.
func (c *UserClient) QueryTransportRecipients(u *User) *TransportRecipientQuery {
	query := &TransportRecipientQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(transportrecipient.Table, transportrecipient.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.TransportRecipientsTable, user.TransportRecipientsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	hooks := c.hooks.User
	return append(hooks[:len(hooks):len(hooks)], user.Hooks[:]...)
}

// UserMetaDataClient is a client for the UserMetaData schema.
type UserMetaDataClient struct {
	config
}

// NewUserMetaDataClient returns a client for the UserMetaData from the given config.
func NewUserMetaDataClient(c config) *UserMetaDataClient {
	return &UserMetaDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usermetadata.Hooks(f(g(h())))`.
func (c *UserMetaDataClient) Use(hooks ...Hook) {
	c.hooks.UserMetaData = append(c.hooks.UserMetaData, hooks...)
}

// Create returns a builder for creating a UserMetaData entity.
func (c *UserMetaDataClient) Create() *UserMetaDataCreate {
	mutation := newUserMetaDataMutation(c.config, OpCreate)
	return &UserMetaDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserMetaData entities.
func (c *UserMetaDataClient) CreateBulk(builders ...*UserMetaDataCreate) *UserMetaDataCreateBulk {
	return &UserMetaDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserMetaData.
func (c *UserMetaDataClient) Update() *UserMetaDataUpdate {
	mutation := newUserMetaDataMutation(c.config, OpUpdate)
	return &UserMetaDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserMetaDataClient) UpdateOne(umd *UserMetaData) *UserMetaDataUpdateOne {
	mutation := newUserMetaDataMutation(c.config, OpUpdateOne, withUserMetaData(umd))
	return &UserMetaDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserMetaDataClient) UpdateOneID(id int) *UserMetaDataUpdateOne {
	mutation := newUserMetaDataMutation(c.config, OpUpdateOne, withUserMetaDataID(id))
	return &UserMetaDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserMetaData.
func (c *UserMetaDataClient) Delete() *UserMetaDataDelete {
	mutation := newUserMetaDataMutation(c.config, OpDelete)
	return &UserMetaDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserMetaDataClient) DeleteOne(umd *UserMetaData) *UserMetaDataDeleteOne {
	return c.DeleteOneID(umd.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *UserMetaDataClient) DeleteOneID(id int) *UserMetaDataDeleteOne {
	builder := c.Delete().Where(usermetadata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserMetaDataDeleteOne{builder}
}

// Query returns a query builder for UserMetaData.
func (c *UserMetaDataClient) Query() *UserMetaDataQuery {
	return &UserMetaDataQuery{
		config: c.config,
	}
}

// Get returns a UserMetaData entity by its id.
func (c *UserMetaDataClient) Get(ctx context.Context, id int) (*UserMetaData, error) {
	return c.Query().Where(usermetadata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserMetaDataClient) GetX(ctx context.Context, id int) *UserMetaData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a UserMetaData.
func (c *UserMetaDataClient) QueryTenant(umd *UserMetaData) *TenantQuery {
	query := &TenantQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := umd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usermetadata.Table, usermetadata.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, usermetadata.TenantTable, usermetadata.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(umd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a UserMetaData.
func (c *UserMetaDataClient) QueryUser(umd *UserMetaData) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := umd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usermetadata.Table, usermetadata.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, usermetadata.UserTable, usermetadata.UserColumn),
		)
		fromV = sqlgraph.Neighbors(umd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserMetaDataClient) Hooks() []Hook {
	hooks := c.hooks.UserMetaData
	return append(hooks[:len(hooks):len(hooks)], usermetadata.Hooks[:]...)
}
