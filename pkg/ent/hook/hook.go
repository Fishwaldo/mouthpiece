/*
	MIT License

	Copyright (c) 2021 Justin Hammond

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
*/

// Code generated by entc, DO NOT EDIT.

package hook

import (
	"context"
	"fmt"

	"github.com/Fishwaldo/mouthpiece/pkg/ent"
)

// The DbAppFunc type is an adapter to allow the use of ordinary
// function as DbApp mutator.
type DbAppFunc func(context.Context, *ent.DbAppMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f DbAppFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) {
	mv, ok := m.(*ent.DbAppMutation)
	if !ok {
		return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.DbAppMutation", m)
	}
	return f(ctx, mv)
}

// The DbFilterFunc type is an adapter to allow the use of ordinary
// function as DbFilter mutator.
type DbFilterFunc func(context.Context, *ent.DbFilterMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f DbFilterFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) {
	mv, ok := m.(*ent.DbFilterMutation)
	if !ok {
		return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.DbFilterMutation", m)
	}
	return f(ctx, mv)
}

// The DbGroupFunc type is an adapter to allow the use of ordinary
// function as DbGroup mutator.
type DbGroupFunc func(context.Context, *ent.DbGroupMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f DbGroupFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) {
	mv, ok := m.(*ent.DbGroupMutation)
	if !ok {
		return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.DbGroupMutation", m)
	}
	return f(ctx, mv)
}

// The DbMessageFunc type is an adapter to allow the use of ordinary
// function as DbMessage mutator.
type DbMessageFunc func(context.Context, *ent.DbMessageMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f DbMessageFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) {
	mv, ok := m.(*ent.DbMessageMutation)
	if !ok {
		return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.DbMessageMutation", m)
	}
	return f(ctx, mv)
}

// The DbMessageFieldsFunc type is an adapter to allow the use of ordinary
// function as DbMessageFields mutator.
type DbMessageFieldsFunc func(context.Context, *ent.DbMessageFieldsMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f DbMessageFieldsFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) {
	mv, ok := m.(*ent.DbMessageFieldsMutation)
	if !ok {
		return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.DbMessageFieldsMutation", m)
	}
	return f(ctx, mv)
}

// The DbTransportInstancesFunc type is an adapter to allow the use of ordinary
// function as DbTransportInstances mutator.
type DbTransportInstancesFunc func(context.Context, *ent.DbTransportInstancesMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f DbTransportInstancesFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) {
	mv, ok := m.(*ent.DbTransportInstancesMutation)
	if !ok {
		return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.DbTransportInstancesMutation", m)
	}
	return f(ctx, mv)
}

// The DbTransportRecipientsFunc type is an adapter to allow the use of ordinary
// function as DbTransportRecipients mutator.
type DbTransportRecipientsFunc func(context.Context, *ent.DbTransportRecipientsMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f DbTransportRecipientsFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) {
	mv, ok := m.(*ent.DbTransportRecipientsMutation)
	if !ok {
		return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.DbTransportRecipientsMutation", m)
	}
	return f(ctx, mv)
}

// The DbUserFunc type is an adapter to allow the use of ordinary
// function as DbUser mutator.
type DbUserFunc func(context.Context, *ent.DbUserMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f DbUserFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) {
	mv, ok := m.(*ent.DbUserMutation)
	if !ok {
		return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.DbUserMutation", m)
	}
	return f(ctx, mv)
}

// The DbUserMetaDataFunc type is an adapter to allow the use of ordinary
// function as DbUserMetaData mutator.
type DbUserMetaDataFunc func(context.Context, *ent.DbUserMetaDataMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f DbUserMetaDataFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) {
	mv, ok := m.(*ent.DbUserMetaDataMutation)
	if !ok {
		return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.DbUserMetaDataMutation", m)
	}
	return f(ctx, mv)
}

// The TenantFunc type is an adapter to allow the use of ordinary
// function as Tenant mutator.
type TenantFunc func(context.Context, *ent.TenantMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f TenantFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) {
	mv, ok := m.(*ent.TenantMutation)
	if !ok {
		return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.TenantMutation", m)
	}
	return f(ctx, mv)
}

// Condition is a hook condition function.
type Condition func(context.Context, ent.Mutation) bool

// And groups conditions with the AND operator.
func And(first, second Condition, rest ...Condition) Condition {
	return func(ctx context.Context, m ent.Mutation) bool {
		if !first(ctx, m) || !second(ctx, m) {
			return false
		}
		for _, cond := range rest {
			if !cond(ctx, m) {
				return false
			}
		}
		return true
	}
}

// Or groups conditions with the OR operator.
func Or(first, second Condition, rest ...Condition) Condition {
	return func(ctx context.Context, m ent.Mutation) bool {
		if first(ctx, m) || second(ctx, m) {
			return true
		}
		for _, cond := range rest {
			if cond(ctx, m) {
				return true
			}
		}
		return false
	}
}

// Not negates a given condition.
func Not(cond Condition) Condition {
	return func(ctx context.Context, m ent.Mutation) bool {
		return !cond(ctx, m)
	}
}

// HasOp is a condition testing mutation operation.
func HasOp(op ent.Op) Condition {
	return func(_ context.Context, m ent.Mutation) bool {
		return m.Op().Is(op)
	}
}

// HasAddedFields is a condition validating `.AddedField` on fields.
func HasAddedFields(field string, fields ...string) Condition {
	return func(_ context.Context, m ent.Mutation) bool {
		if _, exists := m.AddedField(field); !exists {
			return false
		}
		for _, field := range fields {
			if _, exists := m.AddedField(field); !exists {
				return false
			}
		}
		return true
	}
}

// HasClearedFields is a condition validating `.FieldCleared` on fields.
func HasClearedFields(field string, fields ...string) Condition {
	return func(_ context.Context, m ent.Mutation) bool {
		if exists := m.FieldCleared(field); !exists {
			return false
		}
		for _, field := range fields {
			if exists := m.FieldCleared(field); !exists {
				return false
			}
		}
		return true
	}
}

// HasFields is a condition validating `.Field` on fields.
func HasFields(field string, fields ...string) Condition {
	return func(_ context.Context, m ent.Mutation) bool {
		if _, exists := m.Field(field); !exists {
			return false
		}
		for _, field := range fields {
			if _, exists := m.Field(field); !exists {
				return false
			}
		}
		return true
	}
}

// If executes the given hook under condition.
//
//	hook.If(ComputeAverage, And(HasFields(...), HasAddedFields(...)))
func If(hk ent.Hook, cond Condition) ent.Hook {
	return func(next ent.Mutator) ent.Mutator {
		return ent.MutateFunc(func(ctx context.Context, m ent.Mutation) (ent.Value, error) {
			if cond(ctx, m) {
				return hk(next).Mutate(ctx, m)
			}
			return next.Mutate(ctx, m)
		})
	}
}

// On executes the given hook only for the given operation.
//
//	hook.On(Log, ent.Delete|ent.Create)
func On(hk ent.Hook, op ent.Op) ent.Hook {
	return If(hk, HasOp(op))
}

// Unless skips the given hook only for the given operation.
//
//	hook.Unless(Log, ent.Update|ent.UpdateOne)
func Unless(hk ent.Hook, op ent.Op) ent.Hook {
	return If(hk, Not(HasOp(op)))
}

// FixedError is a hook returning a fixed error.
func FixedError(err error) ent.Hook {
	return func(ent.Mutator) ent.Mutator {
		return ent.MutateFunc(func(context.Context, ent.Mutation) (ent.Value, error) {
			return nil, err
		})
	}
}

// Reject returns a hook that rejects all operations that match op.
//
//	func (T) Hooks() []ent.Hook {
//		return []ent.Hook{
//			Reject(ent.Delete|ent.Update),
//		}
//	}
func Reject(op ent.Op) ent.Hook {
	hk := FixedError(fmt.Errorf("%s operation is not allowed", op))
	return On(hk, op)
}

// Chain acts as a list of hooks and is effectively immutable.
// Once created, it will always hold the same set of hooks in the same order.
type Chain struct {
	hooks []ent.Hook
}

// NewChain creates a new chain of hooks.
func NewChain(hooks ...ent.Hook) Chain {
	return Chain{append([]ent.Hook(nil), hooks...)}
}

// Hook chains the list of hooks and returns the final hook.
func (c Chain) Hook() ent.Hook {
	return func(mutator ent.Mutator) ent.Mutator {
		for i := len(c.hooks) - 1; i >= 0; i-- {
			mutator = c.hooks[i](mutator)
		}
		return mutator
	}
}

// Append extends a chain, adding the specified hook
// as the last ones in the mutation flow.
func (c Chain) Append(hooks ...ent.Hook) Chain {
	newHooks := make([]ent.Hook, 0, len(c.hooks)+len(hooks))
	newHooks = append(newHooks, c.hooks...)
	newHooks = append(newHooks, hooks...)
	return Chain{newHooks}
}

// Extend extends a chain, adding the specified chain
// as the last ones in the mutation flow.
func (c Chain) Extend(chain Chain) Chain {
	return c.Append(chain.hooks...)
}
