/*
	MIT License

	Copyright (c) 2021 Justin Hammond

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
*/

// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/Fishwaldo/mouthpiece/pkg/ent/app"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/filter"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/filterconfig"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/group"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/message"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/msgvar"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/predicate"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/tenant"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/transportinstance"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/transportrecipient"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/user"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/usermetadata"
	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApp                = "App"
	TypeFilter             = "Filter"
	TypeFilterConfig       = "FilterConfig"
	TypeGroup              = "Group"
	TypeMessage            = "Message"
	TypeMsgVar             = "MsgVar"
	TypeTenant             = "Tenant"
	TypeTransportInstance  = "TransportInstance"
	TypeTransportRecipient = "TransportRecipient"
	TypeUser               = "User"
	TypeUserMetaData       = "UserMetaData"
)

// AppMutation represents an operation that mutates the App nodes in the graph.
type AppMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	_Name                       *string
	_Status                     *app.Status
	_Description                *string
	icon                        *string
	url                         *string
	clearedFields               map[string]struct{}
	tenant                      *int
	clearedtenant               bool
	messages                    map[uuid.UUID]struct{}
	removedmessages             map[uuid.UUID]struct{}
	clearedmessages             bool
	filters                     map[int]struct{}
	removedfilters              map[int]struct{}
	clearedfilters              bool
	groups                      map[int]struct{}
	removedgroups               map[int]struct{}
	clearedgroups               bool
	_TransportRecipients        map[int]struct{}
	removed_TransportRecipients map[int]struct{}
	cleared_TransportRecipients bool
	done                        bool
	oldValue                    func(context.Context) (*App, error)
	predicates                  []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows management of the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for the App entity.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the ID field of the mutation.
func withAppID(id int) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().App.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *AppMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *AppMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *AppMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "Name" field.
func (m *AppMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *AppMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *AppMutation) ResetName() {
	m._Name = nil
}

// SetStatus sets the "Status" field.
func (m *AppMutation) SetStatus(a app.Status) {
	m._Status = &a
}

// Status returns the value of the "Status" field in the mutation.
func (m *AppMutation) Status() (r app.Status, exists bool) {
	v := m._Status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "Status" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldStatus(ctx context.Context) (v app.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "Status" field.
func (m *AppMutation) ResetStatus() {
	m._Status = nil
}

// SetDescription sets the "Description" field.
func (m *AppMutation) SetDescription(s string) {
	m._Description = &s
}

// Description returns the value of the "Description" field in the mutation.
func (m *AppMutation) Description() (r string, exists bool) {
	v := m._Description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "Description" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "Description" field.
func (m *AppMutation) ResetDescription() {
	m._Description = nil
}

// SetIcon sets the "icon" field.
func (m *AppMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *AppMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ResetIcon resets all changes to the "icon" field.
func (m *AppMutation) ResetIcon() {
	m.icon = nil
}

// SetURL sets the "url" field.
func (m *AppMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *AppMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *AppMutation) ResetURL() {
	m.url = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *AppMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *AppMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *AppMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *AppMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddMessageIDs adds the "messages" edge to the Message entity by ids.
func (m *AppMutation) AddMessageIDs(ids ...uuid.UUID) {
	if m.messages == nil {
		m.messages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the Message entity.
func (m *AppMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the Message entity was cleared.
func (m *AppMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the Message entity by IDs.
func (m *AppMutation) RemoveMessageIDs(ids ...uuid.UUID) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the Message entity.
func (m *AppMutation) RemovedMessagesIDs() (ids []uuid.UUID) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *AppMutation) MessagesIDs() (ids []uuid.UUID) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *AppMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// AddFilterIDs adds the "filters" edge to the Filter entity by ids.
func (m *AppMutation) AddFilterIDs(ids ...int) {
	if m.filters == nil {
		m.filters = make(map[int]struct{})
	}
	for i := range ids {
		m.filters[ids[i]] = struct{}{}
	}
}

// ClearFilters clears the "filters" edge to the Filter entity.
func (m *AppMutation) ClearFilters() {
	m.clearedfilters = true
}

// FiltersCleared reports if the "filters" edge to the Filter entity was cleared.
func (m *AppMutation) FiltersCleared() bool {
	return m.clearedfilters
}

// RemoveFilterIDs removes the "filters" edge to the Filter entity by IDs.
func (m *AppMutation) RemoveFilterIDs(ids ...int) {
	if m.removedfilters == nil {
		m.removedfilters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.filters, ids[i])
		m.removedfilters[ids[i]] = struct{}{}
	}
}

// RemovedFilters returns the removed IDs of the "filters" edge to the Filter entity.
func (m *AppMutation) RemovedFiltersIDs() (ids []int) {
	for id := range m.removedfilters {
		ids = append(ids, id)
	}
	return
}

// FiltersIDs returns the "filters" edge IDs in the mutation.
func (m *AppMutation) FiltersIDs() (ids []int) {
	for id := range m.filters {
		ids = append(ids, id)
	}
	return
}

// ResetFilters resets all changes to the "filters" edge.
func (m *AppMutation) ResetFilters() {
	m.filters = nil
	m.clearedfilters = false
	m.removedfilters = nil
}

// AddGroupIDs adds the "groups" edge to the Group entity by ids.
func (m *AppMutation) AddGroupIDs(ids ...int) {
	if m.groups == nil {
		m.groups = make(map[int]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the "groups" edge to the Group entity.
func (m *AppMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared reports if the "groups" edge to the Group entity was cleared.
func (m *AppMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the "groups" edge to the Group entity by IDs.
func (m *AppMutation) RemoveGroupIDs(ids ...int) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.groups, ids[i])
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed IDs of the "groups" edge to the Group entity.
func (m *AppMutation) RemovedGroupsIDs() (ids []int) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the "groups" edge IDs in the mutation.
func (m *AppMutation) GroupsIDs() (ids []int) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups resets all changes to the "groups" edge.
func (m *AppMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// AddTransportRecipientIDs adds the "TransportRecipients" edge to the TransportRecipient entity by ids.
func (m *AppMutation) AddTransportRecipientIDs(ids ...int) {
	if m._TransportRecipients == nil {
		m._TransportRecipients = make(map[int]struct{})
	}
	for i := range ids {
		m._TransportRecipients[ids[i]] = struct{}{}
	}
}

// ClearTransportRecipients clears the "TransportRecipients" edge to the TransportRecipient entity.
func (m *AppMutation) ClearTransportRecipients() {
	m.cleared_TransportRecipients = true
}

// TransportRecipientsCleared reports if the "TransportRecipients" edge to the TransportRecipient entity was cleared.
func (m *AppMutation) TransportRecipientsCleared() bool {
	return m.cleared_TransportRecipients
}

// RemoveTransportRecipientIDs removes the "TransportRecipients" edge to the TransportRecipient entity by IDs.
func (m *AppMutation) RemoveTransportRecipientIDs(ids ...int) {
	if m.removed_TransportRecipients == nil {
		m.removed_TransportRecipients = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._TransportRecipients, ids[i])
		m.removed_TransportRecipients[ids[i]] = struct{}{}
	}
}

// RemovedTransportRecipients returns the removed IDs of the "TransportRecipients" edge to the TransportRecipient entity.
func (m *AppMutation) RemovedTransportRecipientsIDs() (ids []int) {
	for id := range m.removed_TransportRecipients {
		ids = append(ids, id)
	}
	return
}

// TransportRecipientsIDs returns the "TransportRecipients" edge IDs in the mutation.
func (m *AppMutation) TransportRecipientsIDs() (ids []int) {
	for id := range m._TransportRecipients {
		ids = append(ids, id)
	}
	return
}

// ResetTransportRecipients resets all changes to the "TransportRecipients" edge.
func (m *AppMutation) ResetTransportRecipients() {
	m._TransportRecipients = nil
	m.cleared_TransportRecipients = false
	m.removed_TransportRecipients = nil
}

// Where appends a list predicates to the AppMutation builder.
func (m *AppMutation) Where(ps ...predicate.App) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.tenant != nil {
		fields = append(fields, app.FieldTenantID)
	}
	if m._Name != nil {
		fields = append(fields, app.FieldName)
	}
	if m._Status != nil {
		fields = append(fields, app.FieldStatus)
	}
	if m._Description != nil {
		fields = append(fields, app.FieldDescription)
	}
	if m.icon != nil {
		fields = append(fields, app.FieldIcon)
	}
	if m.url != nil {
		fields = append(fields, app.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case app.FieldTenantID:
		return m.TenantID()
	case app.FieldName:
		return m.Name()
	case app.FieldStatus:
		return m.Status()
	case app.FieldDescription:
		return m.Description()
	case app.FieldIcon:
		return m.Icon()
	case app.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case app.FieldTenantID:
		return m.OldTenantID(ctx)
	case app.FieldName:
		return m.OldName(ctx)
	case app.FieldStatus:
		return m.OldStatus(ctx)
	case app.FieldDescription:
		return m.OldDescription(ctx)
	case app.FieldIcon:
		return m.OldIcon(ctx)
	case app.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case app.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case app.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case app.FieldStatus:
		v, ok := value.(app.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case app.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case app.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case app.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case app.FieldTenantID:
		m.ResetTenantID()
		return nil
	case app.FieldName:
		m.ResetName()
		return nil
	case app.FieldStatus:
		m.ResetStatus()
		return nil
	case app.FieldDescription:
		m.ResetDescription()
		return nil
	case app.FieldIcon:
		m.ResetIcon()
		return nil
	case app.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.tenant != nil {
		edges = append(edges, app.EdgeTenant)
	}
	if m.messages != nil {
		edges = append(edges, app.EdgeMessages)
	}
	if m.filters != nil {
		edges = append(edges, app.EdgeFilters)
	}
	if m.groups != nil {
		edges = append(edges, app.EdgeGroups)
	}
	if m._TransportRecipients != nil {
		edges = append(edges, app.EdgeTransportRecipients)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case app.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeFilters:
		ids := make([]ent.Value, 0, len(m.filters))
		for id := range m.filters {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeTransportRecipients:
		ids := make([]ent.Value, 0, len(m._TransportRecipients))
		for id := range m._TransportRecipients {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedmessages != nil {
		edges = append(edges, app.EdgeMessages)
	}
	if m.removedfilters != nil {
		edges = append(edges, app.EdgeFilters)
	}
	if m.removedgroups != nil {
		edges = append(edges, app.EdgeGroups)
	}
	if m.removed_TransportRecipients != nil {
		edges = append(edges, app.EdgeTransportRecipients)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeFilters:
		ids := make([]ent.Value, 0, len(m.removedfilters))
		for id := range m.removedfilters {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeTransportRecipients:
		ids := make([]ent.Value, 0, len(m.removed_TransportRecipients))
		for id := range m.removed_TransportRecipients {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtenant {
		edges = append(edges, app.EdgeTenant)
	}
	if m.clearedmessages {
		edges = append(edges, app.EdgeMessages)
	}
	if m.clearedfilters {
		edges = append(edges, app.EdgeFilters)
	}
	if m.clearedgroups {
		edges = append(edges, app.EdgeGroups)
	}
	if m.cleared_TransportRecipients {
		edges = append(edges, app.EdgeTransportRecipients)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	switch name {
	case app.EdgeTenant:
		return m.clearedtenant
	case app.EdgeMessages:
		return m.clearedmessages
	case app.EdgeFilters:
		return m.clearedfilters
	case app.EdgeGroups:
		return m.clearedgroups
	case app.EdgeTransportRecipients:
		return m.cleared_TransportRecipients
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	switch name {
	case app.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	switch name {
	case app.EdgeTenant:
		m.ResetTenant()
		return nil
	case app.EdgeMessages:
		m.ResetMessages()
		return nil
	case app.EdgeFilters:
		m.ResetFilters()
		return nil
	case app.EdgeGroups:
		m.ResetGroups()
		return nil
	case app.EdgeTransportRecipients:
		m.ResetTransportRecipients()
		return nil
	}
	return fmt.Errorf("unknown App edge %s", name)
}

// FilterMutation represents an operation that mutates the Filter nodes in the graph.
type FilterMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_Name          *string
	_Description   *string
	_Type          *filter.Type
	_Enabled       *bool
	_FilterImpl    *string
	clearedFields  map[string]struct{}
	tenant         *int
	clearedtenant  bool
	_config        map[int]struct{}
	removed_config map[int]struct{}
	cleared_config bool
	groups         map[int]struct{}
	removedgroups  map[int]struct{}
	clearedgroups  bool
	app            map[int]struct{}
	removedapp     map[int]struct{}
	clearedapp     bool
	user           map[int]struct{}
	removeduser    map[int]struct{}
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*Filter, error)
	predicates     []predicate.Filter
}

var _ ent.Mutation = (*FilterMutation)(nil)

// filterOption allows management of the mutation configuration using functional options.
type filterOption func(*FilterMutation)

// newFilterMutation creates new mutation for the Filter entity.
func newFilterMutation(c config, op Op, opts ...filterOption) *FilterMutation {
	m := &FilterMutation{
		config:        c,
		op:            op,
		typ:           TypeFilter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFilterID sets the ID field of the mutation.
func withFilterID(id int) filterOption {
	return func(m *FilterMutation) {
		var (
			err   error
			once  sync.Once
			value *Filter
		)
		m.oldValue = func(ctx context.Context) (*Filter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Filter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFilter sets the old Filter of the mutation.
func withFilter(node *Filter) filterOption {
	return func(m *FilterMutation) {
		m.oldValue = func(context.Context) (*Filter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FilterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FilterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FilterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FilterMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Filter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *FilterMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *FilterMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *FilterMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "Name" field.
func (m *FilterMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *FilterMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *FilterMutation) ResetName() {
	m._Name = nil
}

// SetDescription sets the "Description" field.
func (m *FilterMutation) SetDescription(s string) {
	m._Description = &s
}

// Description returns the value of the "Description" field in the mutation.
func (m *FilterMutation) Description() (r string, exists bool) {
	v := m._Description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "Description" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "Description" field.
func (m *FilterMutation) ResetDescription() {
	m._Description = nil
}

// SetType sets the "Type" field.
func (m *FilterMutation) SetType(f filter.Type) {
	m._Type = &f
}

// GetType returns the value of the "Type" field in the mutation.
func (m *FilterMutation) GetType() (r filter.Type, exists bool) {
	v := m._Type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "Type" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldType(ctx context.Context) (v filter.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "Type" field.
func (m *FilterMutation) ResetType() {
	m._Type = nil
}

// SetEnabled sets the "Enabled" field.
func (m *FilterMutation) SetEnabled(b bool) {
	m._Enabled = &b
}

// Enabled returns the value of the "Enabled" field in the mutation.
func (m *FilterMutation) Enabled() (r bool, exists bool) {
	v := m._Enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "Enabled" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "Enabled" field.
func (m *FilterMutation) ResetEnabled() {
	m._Enabled = nil
}

// SetFilterImpl sets the "FilterImpl" field.
func (m *FilterMutation) SetFilterImpl(s string) {
	m._FilterImpl = &s
}

// FilterImpl returns the value of the "FilterImpl" field in the mutation.
func (m *FilterMutation) FilterImpl() (r string, exists bool) {
	v := m._FilterImpl
	if v == nil {
		return
	}
	return *v, true
}

// OldFilterImpl returns the old "FilterImpl" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldFilterImpl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilterImpl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilterImpl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilterImpl: %w", err)
	}
	return oldValue.FilterImpl, nil
}

// ResetFilterImpl resets all changes to the "FilterImpl" field.
func (m *FilterMutation) ResetFilterImpl() {
	m._FilterImpl = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *FilterMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *FilterMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *FilterMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *FilterMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddConfigIDs adds the "config" edge to the FilterConfig entity by ids.
func (m *FilterMutation) AddConfigIDs(ids ...int) {
	if m._config == nil {
		m._config = make(map[int]struct{})
	}
	for i := range ids {
		m._config[ids[i]] = struct{}{}
	}
}

// ClearConfig clears the "config" edge to the FilterConfig entity.
func (m *FilterMutation) ClearConfig() {
	m.cleared_config = true
}

// ConfigCleared reports if the "config" edge to the FilterConfig entity was cleared.
func (m *FilterMutation) ConfigCleared() bool {
	return m.cleared_config
}

// RemoveConfigIDs removes the "config" edge to the FilterConfig entity by IDs.
func (m *FilterMutation) RemoveConfigIDs(ids ...int) {
	if m.removed_config == nil {
		m.removed_config = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._config, ids[i])
		m.removed_config[ids[i]] = struct{}{}
	}
}

// RemovedConfig returns the removed IDs of the "config" edge to the FilterConfig entity.
func (m *FilterMutation) RemovedConfigIDs() (ids []int) {
	for id := range m.removed_config {
		ids = append(ids, id)
	}
	return
}

// ConfigIDs returns the "config" edge IDs in the mutation.
func (m *FilterMutation) ConfigIDs() (ids []int) {
	for id := range m._config {
		ids = append(ids, id)
	}
	return
}

// ResetConfig resets all changes to the "config" edge.
func (m *FilterMutation) ResetConfig() {
	m._config = nil
	m.cleared_config = false
	m.removed_config = nil
}

// AddGroupIDs adds the "groups" edge to the Group entity by ids.
func (m *FilterMutation) AddGroupIDs(ids ...int) {
	if m.groups == nil {
		m.groups = make(map[int]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the "groups" edge to the Group entity.
func (m *FilterMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared reports if the "groups" edge to the Group entity was cleared.
func (m *FilterMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the "groups" edge to the Group entity by IDs.
func (m *FilterMutation) RemoveGroupIDs(ids ...int) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.groups, ids[i])
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed IDs of the "groups" edge to the Group entity.
func (m *FilterMutation) RemovedGroupsIDs() (ids []int) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the "groups" edge IDs in the mutation.
func (m *FilterMutation) GroupsIDs() (ids []int) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups resets all changes to the "groups" edge.
func (m *FilterMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// AddAppIDs adds the "app" edge to the App entity by ids.
func (m *FilterMutation) AddAppIDs(ids ...int) {
	if m.app == nil {
		m.app = make(map[int]struct{})
	}
	for i := range ids {
		m.app[ids[i]] = struct{}{}
	}
}

// ClearApp clears the "app" edge to the App entity.
func (m *FilterMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *FilterMutation) AppCleared() bool {
	return m.clearedapp
}

// RemoveAppIDs removes the "app" edge to the App entity by IDs.
func (m *FilterMutation) RemoveAppIDs(ids ...int) {
	if m.removedapp == nil {
		m.removedapp = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.app, ids[i])
		m.removedapp[ids[i]] = struct{}{}
	}
}

// RemovedApp returns the removed IDs of the "app" edge to the App entity.
func (m *FilterMutation) RemovedAppIDs() (ids []int) {
	for id := range m.removedapp {
		ids = append(ids, id)
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
func (m *FilterMutation) AppIDs() (ids []int) {
	for id := range m.app {
		ids = append(ids, id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *FilterMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
	m.removedapp = nil
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *FilterMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *FilterMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *FilterMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *FilterMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *FilterMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *FilterMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *FilterMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// Where appends a list predicates to the FilterMutation builder.
func (m *FilterMutation) Where(ps ...predicate.Filter) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FilterMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Filter).
func (m *FilterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FilterMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.tenant != nil {
		fields = append(fields, filter.FieldTenantID)
	}
	if m._Name != nil {
		fields = append(fields, filter.FieldName)
	}
	if m._Description != nil {
		fields = append(fields, filter.FieldDescription)
	}
	if m._Type != nil {
		fields = append(fields, filter.FieldType)
	}
	if m._Enabled != nil {
		fields = append(fields, filter.FieldEnabled)
	}
	if m._FilterImpl != nil {
		fields = append(fields, filter.FieldFilterImpl)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FilterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filter.FieldTenantID:
		return m.TenantID()
	case filter.FieldName:
		return m.Name()
	case filter.FieldDescription:
		return m.Description()
	case filter.FieldType:
		return m.GetType()
	case filter.FieldEnabled:
		return m.Enabled()
	case filter.FieldFilterImpl:
		return m.FilterImpl()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FilterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filter.FieldTenantID:
		return m.OldTenantID(ctx)
	case filter.FieldName:
		return m.OldName(ctx)
	case filter.FieldDescription:
		return m.OldDescription(ctx)
	case filter.FieldType:
		return m.OldType(ctx)
	case filter.FieldEnabled:
		return m.OldEnabled(ctx)
	case filter.FieldFilterImpl:
		return m.OldFilterImpl(ctx)
	}
	return nil, fmt.Errorf("unknown Filter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filter.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case filter.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case filter.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case filter.FieldType:
		v, ok := value.(filter.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case filter.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case filter.FieldFilterImpl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilterImpl(v)
		return nil
	}
	return fmt.Errorf("unknown Filter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FilterMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FilterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Filter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FilterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FilterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FilterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Filter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FilterMutation) ResetField(name string) error {
	switch name {
	case filter.FieldTenantID:
		m.ResetTenantID()
		return nil
	case filter.FieldName:
		m.ResetName()
		return nil
	case filter.FieldDescription:
		m.ResetDescription()
		return nil
	case filter.FieldType:
		m.ResetType()
		return nil
	case filter.FieldEnabled:
		m.ResetEnabled()
		return nil
	case filter.FieldFilterImpl:
		m.ResetFilterImpl()
		return nil
	}
	return fmt.Errorf("unknown Filter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FilterMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.tenant != nil {
		edges = append(edges, filter.EdgeTenant)
	}
	if m._config != nil {
		edges = append(edges, filter.EdgeConfig)
	}
	if m.groups != nil {
		edges = append(edges, filter.EdgeGroups)
	}
	if m.app != nil {
		edges = append(edges, filter.EdgeApp)
	}
	if m.user != nil {
		edges = append(edges, filter.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FilterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case filter.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case filter.EdgeConfig:
		ids := make([]ent.Value, 0, len(m._config))
		for id := range m._config {
			ids = append(ids, id)
		}
		return ids
	case filter.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	case filter.EdgeApp:
		ids := make([]ent.Value, 0, len(m.app))
		for id := range m.app {
			ids = append(ids, id)
		}
		return ids
	case filter.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FilterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removed_config != nil {
		edges = append(edges, filter.EdgeConfig)
	}
	if m.removedgroups != nil {
		edges = append(edges, filter.EdgeGroups)
	}
	if m.removedapp != nil {
		edges = append(edges, filter.EdgeApp)
	}
	if m.removeduser != nil {
		edges = append(edges, filter.EdgeUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FilterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case filter.EdgeConfig:
		ids := make([]ent.Value, 0, len(m.removed_config))
		for id := range m.removed_config {
			ids = append(ids, id)
		}
		return ids
	case filter.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	case filter.EdgeApp:
		ids := make([]ent.Value, 0, len(m.removedapp))
		for id := range m.removedapp {
			ids = append(ids, id)
		}
		return ids
	case filter.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FilterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtenant {
		edges = append(edges, filter.EdgeTenant)
	}
	if m.cleared_config {
		edges = append(edges, filter.EdgeConfig)
	}
	if m.clearedgroups {
		edges = append(edges, filter.EdgeGroups)
	}
	if m.clearedapp {
		edges = append(edges, filter.EdgeApp)
	}
	if m.cleareduser {
		edges = append(edges, filter.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FilterMutation) EdgeCleared(name string) bool {
	switch name {
	case filter.EdgeTenant:
		return m.clearedtenant
	case filter.EdgeConfig:
		return m.cleared_config
	case filter.EdgeGroups:
		return m.clearedgroups
	case filter.EdgeApp:
		return m.clearedapp
	case filter.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FilterMutation) ClearEdge(name string) error {
	switch name {
	case filter.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Filter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FilterMutation) ResetEdge(name string) error {
	switch name {
	case filter.EdgeTenant:
		m.ResetTenant()
		return nil
	case filter.EdgeConfig:
		m.ResetConfig()
		return nil
	case filter.EdgeGroups:
		m.ResetGroups()
		return nil
	case filter.EdgeApp:
		m.ResetApp()
		return nil
	case filter.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Filter edge %s", name)
}

// FilterConfigMutation represents an operation that mutates the FilterConfig nodes in the graph.
type FilterConfigMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Name         *string
	_Value        *string
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	filter        *int
	clearedfilter bool
	done          bool
	oldValue      func(context.Context) (*FilterConfig, error)
	predicates    []predicate.FilterConfig
}

var _ ent.Mutation = (*FilterConfigMutation)(nil)

// filterconfigOption allows management of the mutation configuration using functional options.
type filterconfigOption func(*FilterConfigMutation)

// newFilterConfigMutation creates new mutation for the FilterConfig entity.
func newFilterConfigMutation(c config, op Op, opts ...filterconfigOption) *FilterConfigMutation {
	m := &FilterConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeFilterConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFilterConfigID sets the ID field of the mutation.
func withFilterConfigID(id int) filterconfigOption {
	return func(m *FilterConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *FilterConfig
		)
		m.oldValue = func(ctx context.Context) (*FilterConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FilterConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFilterConfig sets the old FilterConfig of the mutation.
func withFilterConfig(node *FilterConfig) filterconfigOption {
	return func(m *FilterConfigMutation) {
		m.oldValue = func(context.Context) (*FilterConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FilterConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FilterConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FilterConfigMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FilterConfigMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FilterConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *FilterConfigMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *FilterConfigMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the FilterConfig entity.
// If the FilterConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterConfigMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *FilterConfigMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "Name" field.
func (m *FilterConfigMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *FilterConfigMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the FilterConfig entity.
// If the FilterConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterConfigMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *FilterConfigMutation) ResetName() {
	m._Name = nil
}

// SetValue sets the "Value" field.
func (m *FilterConfigMutation) SetValue(s string) {
	m._Value = &s
}

// Value returns the value of the "Value" field in the mutation.
func (m *FilterConfigMutation) Value() (r string, exists bool) {
	v := m._Value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "Value" field's value of the FilterConfig entity.
// If the FilterConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterConfigMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "Value" field.
func (m *FilterConfigMutation) ResetValue() {
	m._Value = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *FilterConfigMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *FilterConfigMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *FilterConfigMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *FilterConfigMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetFilterID sets the "filter" edge to the Filter entity by id.
func (m *FilterConfigMutation) SetFilterID(id int) {
	m.filter = &id
}

// ClearFilter clears the "filter" edge to the Filter entity.
func (m *FilterConfigMutation) ClearFilter() {
	m.clearedfilter = true
}

// FilterCleared reports if the "filter" edge to the Filter entity was cleared.
func (m *FilterConfigMutation) FilterCleared() bool {
	return m.clearedfilter
}

// FilterID returns the "filter" edge ID in the mutation.
func (m *FilterConfigMutation) FilterID() (id int, exists bool) {
	if m.filter != nil {
		return *m.filter, true
	}
	return
}

// FilterIDs returns the "filter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FilterID instead. It exists only for internal usage by the builders.
func (m *FilterConfigMutation) FilterIDs() (ids []int) {
	if id := m.filter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFilter resets all changes to the "filter" edge.
func (m *FilterConfigMutation) ResetFilter() {
	m.filter = nil
	m.clearedfilter = false
}

// Where appends a list predicates to the FilterConfigMutation builder.
func (m *FilterConfigMutation) Where(ps ...predicate.FilterConfig) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FilterConfigMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FilterConfig).
func (m *FilterConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FilterConfigMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tenant != nil {
		fields = append(fields, filterconfig.FieldTenantID)
	}
	if m._Name != nil {
		fields = append(fields, filterconfig.FieldName)
	}
	if m._Value != nil {
		fields = append(fields, filterconfig.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FilterConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filterconfig.FieldTenantID:
		return m.TenantID()
	case filterconfig.FieldName:
		return m.Name()
	case filterconfig.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FilterConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filterconfig.FieldTenantID:
		return m.OldTenantID(ctx)
	case filterconfig.FieldName:
		return m.OldName(ctx)
	case filterconfig.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown FilterConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilterConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filterconfig.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case filterconfig.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case filterconfig.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown FilterConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FilterConfigMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FilterConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilterConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FilterConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FilterConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FilterConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FilterConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FilterConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FilterConfigMutation) ResetField(name string) error {
	switch name {
	case filterconfig.FieldTenantID:
		m.ResetTenantID()
		return nil
	case filterconfig.FieldName:
		m.ResetName()
		return nil
	case filterconfig.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown FilterConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FilterConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, filterconfig.EdgeTenant)
	}
	if m.filter != nil {
		edges = append(edges, filterconfig.EdgeFilter)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FilterConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case filterconfig.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case filterconfig.EdgeFilter:
		if id := m.filter; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FilterConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FilterConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FilterConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, filterconfig.EdgeTenant)
	}
	if m.clearedfilter {
		edges = append(edges, filterconfig.EdgeFilter)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FilterConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case filterconfig.EdgeTenant:
		return m.clearedtenant
	case filterconfig.EdgeFilter:
		return m.clearedfilter
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FilterConfigMutation) ClearEdge(name string) error {
	switch name {
	case filterconfig.EdgeTenant:
		m.ClearTenant()
		return nil
	case filterconfig.EdgeFilter:
		m.ClearFilter()
		return nil
	}
	return fmt.Errorf("unknown FilterConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FilterConfigMutation) ResetEdge(name string) error {
	switch name {
	case filterconfig.EdgeTenant:
		m.ResetTenant()
		return nil
	case filterconfig.EdgeFilter:
		m.ResetFilter()
		return nil
	}
	return fmt.Errorf("unknown FilterConfig edge %s", name)
}

// GroupMutation represents an operation that mutates the Group nodes in the graph.
type GroupMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	_Name                       *string
	_Description                *string
	clearedFields               map[string]struct{}
	tenant                      *int
	clearedtenant               bool
	_TransportRecipients        map[int]struct{}
	removed_TransportRecipients map[int]struct{}
	cleared_TransportRecipients bool
	users                       map[int]struct{}
	removedusers                map[int]struct{}
	clearedusers                bool
	filters                     map[int]struct{}
	removedfilters              map[int]struct{}
	clearedfilters              bool
	apps                        map[int]struct{}
	removedapps                 map[int]struct{}
	clearedapps                 bool
	done                        bool
	oldValue                    func(context.Context) (*Group, error)
	predicates                  []predicate.Group
}

var _ ent.Mutation = (*GroupMutation)(nil)

// groupOption allows management of the mutation configuration using functional options.
type groupOption func(*GroupMutation)

// newGroupMutation creates new mutation for the Group entity.
func newGroupMutation(c config, op Op, opts ...groupOption) *GroupMutation {
	m := &GroupMutation{
		config:        c,
		op:            op,
		typ:           TypeGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupID sets the ID field of the mutation.
func withGroupID(id int) groupOption {
	return func(m *GroupMutation) {
		var (
			err   error
			once  sync.Once
			value *Group
		)
		m.oldValue = func(ctx context.Context) (*Group, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Group.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroup sets the old Group of the mutation.
func withGroup(node *Group) groupOption {
	return func(m *GroupMutation) {
		m.oldValue = func(context.Context) (*Group, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Group.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *GroupMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *GroupMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *GroupMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "Name" field.
func (m *GroupMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *GroupMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *GroupMutation) ResetName() {
	m._Name = nil
}

// SetDescription sets the "Description" field.
func (m *GroupMutation) SetDescription(s string) {
	m._Description = &s
}

// Description returns the value of the "Description" field in the mutation.
func (m *GroupMutation) Description() (r string, exists bool) {
	v := m._Description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "Description" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "Description" field.
func (m *GroupMutation) ResetDescription() {
	m._Description = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *GroupMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *GroupMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *GroupMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *GroupMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddTransportRecipientIDs adds the "TransportRecipients" edge to the TransportRecipient entity by ids.
func (m *GroupMutation) AddTransportRecipientIDs(ids ...int) {
	if m._TransportRecipients == nil {
		m._TransportRecipients = make(map[int]struct{})
	}
	for i := range ids {
		m._TransportRecipients[ids[i]] = struct{}{}
	}
}

// ClearTransportRecipients clears the "TransportRecipients" edge to the TransportRecipient entity.
func (m *GroupMutation) ClearTransportRecipients() {
	m.cleared_TransportRecipients = true
}

// TransportRecipientsCleared reports if the "TransportRecipients" edge to the TransportRecipient entity was cleared.
func (m *GroupMutation) TransportRecipientsCleared() bool {
	return m.cleared_TransportRecipients
}

// RemoveTransportRecipientIDs removes the "TransportRecipients" edge to the TransportRecipient entity by IDs.
func (m *GroupMutation) RemoveTransportRecipientIDs(ids ...int) {
	if m.removed_TransportRecipients == nil {
		m.removed_TransportRecipients = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._TransportRecipients, ids[i])
		m.removed_TransportRecipients[ids[i]] = struct{}{}
	}
}

// RemovedTransportRecipients returns the removed IDs of the "TransportRecipients" edge to the TransportRecipient entity.
func (m *GroupMutation) RemovedTransportRecipientsIDs() (ids []int) {
	for id := range m.removed_TransportRecipients {
		ids = append(ids, id)
	}
	return
}

// TransportRecipientsIDs returns the "TransportRecipients" edge IDs in the mutation.
func (m *GroupMutation) TransportRecipientsIDs() (ids []int) {
	for id := range m._TransportRecipients {
		ids = append(ids, id)
	}
	return
}

// ResetTransportRecipients resets all changes to the "TransportRecipients" edge.
func (m *GroupMutation) ResetTransportRecipients() {
	m._TransportRecipients = nil
	m.cleared_TransportRecipients = false
	m.removed_TransportRecipients = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *GroupMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *GroupMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *GroupMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *GroupMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *GroupMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *GroupMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *GroupMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddFilterIDs adds the "filters" edge to the Filter entity by ids.
func (m *GroupMutation) AddFilterIDs(ids ...int) {
	if m.filters == nil {
		m.filters = make(map[int]struct{})
	}
	for i := range ids {
		m.filters[ids[i]] = struct{}{}
	}
}

// ClearFilters clears the "filters" edge to the Filter entity.
func (m *GroupMutation) ClearFilters() {
	m.clearedfilters = true
}

// FiltersCleared reports if the "filters" edge to the Filter entity was cleared.
func (m *GroupMutation) FiltersCleared() bool {
	return m.clearedfilters
}

// RemoveFilterIDs removes the "filters" edge to the Filter entity by IDs.
func (m *GroupMutation) RemoveFilterIDs(ids ...int) {
	if m.removedfilters == nil {
		m.removedfilters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.filters, ids[i])
		m.removedfilters[ids[i]] = struct{}{}
	}
}

// RemovedFilters returns the removed IDs of the "filters" edge to the Filter entity.
func (m *GroupMutation) RemovedFiltersIDs() (ids []int) {
	for id := range m.removedfilters {
		ids = append(ids, id)
	}
	return
}

// FiltersIDs returns the "filters" edge IDs in the mutation.
func (m *GroupMutation) FiltersIDs() (ids []int) {
	for id := range m.filters {
		ids = append(ids, id)
	}
	return
}

// ResetFilters resets all changes to the "filters" edge.
func (m *GroupMutation) ResetFilters() {
	m.filters = nil
	m.clearedfilters = false
	m.removedfilters = nil
}

// AddAppIDs adds the "apps" edge to the App entity by ids.
func (m *GroupMutation) AddAppIDs(ids ...int) {
	if m.apps == nil {
		m.apps = make(map[int]struct{})
	}
	for i := range ids {
		m.apps[ids[i]] = struct{}{}
	}
}

// ClearApps clears the "apps" edge to the App entity.
func (m *GroupMutation) ClearApps() {
	m.clearedapps = true
}

// AppsCleared reports if the "apps" edge to the App entity was cleared.
func (m *GroupMutation) AppsCleared() bool {
	return m.clearedapps
}

// RemoveAppIDs removes the "apps" edge to the App entity by IDs.
func (m *GroupMutation) RemoveAppIDs(ids ...int) {
	if m.removedapps == nil {
		m.removedapps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.apps, ids[i])
		m.removedapps[ids[i]] = struct{}{}
	}
}

// RemovedApps returns the removed IDs of the "apps" edge to the App entity.
func (m *GroupMutation) RemovedAppsIDs() (ids []int) {
	for id := range m.removedapps {
		ids = append(ids, id)
	}
	return
}

// AppsIDs returns the "apps" edge IDs in the mutation.
func (m *GroupMutation) AppsIDs() (ids []int) {
	for id := range m.apps {
		ids = append(ids, id)
	}
	return
}

// ResetApps resets all changes to the "apps" edge.
func (m *GroupMutation) ResetApps() {
	m.apps = nil
	m.clearedapps = false
	m.removedapps = nil
}

// Where appends a list predicates to the GroupMutation builder.
func (m *GroupMutation) Where(ps ...predicate.Group) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Group).
func (m *GroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tenant != nil {
		fields = append(fields, group.FieldTenantID)
	}
	if m._Name != nil {
		fields = append(fields, group.FieldName)
	}
	if m._Description != nil {
		fields = append(fields, group.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case group.FieldTenantID:
		return m.TenantID()
	case group.FieldName:
		return m.Name()
	case group.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case group.FieldTenantID:
		return m.OldTenantID(ctx)
	case group.FieldName:
		return m.OldName(ctx)
	case group.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Group field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case group.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case group.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case group.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Group numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Group nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupMutation) ResetField(name string) error {
	switch name {
	case group.FieldTenantID:
		m.ResetTenantID()
		return nil
	case group.FieldName:
		m.ResetName()
		return nil
	case group.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.tenant != nil {
		edges = append(edges, group.EdgeTenant)
	}
	if m._TransportRecipients != nil {
		edges = append(edges, group.EdgeTransportRecipients)
	}
	if m.users != nil {
		edges = append(edges, group.EdgeUsers)
	}
	if m.filters != nil {
		edges = append(edges, group.EdgeFilters)
	}
	if m.apps != nil {
		edges = append(edges, group.EdgeApps)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case group.EdgeTransportRecipients:
		ids := make([]ent.Value, 0, len(m._TransportRecipients))
		for id := range m._TransportRecipients {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeFilters:
		ids := make([]ent.Value, 0, len(m.filters))
		for id := range m.filters {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeApps:
		ids := make([]ent.Value, 0, len(m.apps))
		for id := range m.apps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removed_TransportRecipients != nil {
		edges = append(edges, group.EdgeTransportRecipients)
	}
	if m.removedusers != nil {
		edges = append(edges, group.EdgeUsers)
	}
	if m.removedfilters != nil {
		edges = append(edges, group.EdgeFilters)
	}
	if m.removedapps != nil {
		edges = append(edges, group.EdgeApps)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeTransportRecipients:
		ids := make([]ent.Value, 0, len(m.removed_TransportRecipients))
		for id := range m.removed_TransportRecipients {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeFilters:
		ids := make([]ent.Value, 0, len(m.removedfilters))
		for id := range m.removedfilters {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeApps:
		ids := make([]ent.Value, 0, len(m.removedapps))
		for id := range m.removedapps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtenant {
		edges = append(edges, group.EdgeTenant)
	}
	if m.cleared_TransportRecipients {
		edges = append(edges, group.EdgeTransportRecipients)
	}
	if m.clearedusers {
		edges = append(edges, group.EdgeUsers)
	}
	if m.clearedfilters {
		edges = append(edges, group.EdgeFilters)
	}
	if m.clearedapps {
		edges = append(edges, group.EdgeApps)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupMutation) EdgeCleared(name string) bool {
	switch name {
	case group.EdgeTenant:
		return m.clearedtenant
	case group.EdgeTransportRecipients:
		return m.cleared_TransportRecipients
	case group.EdgeUsers:
		return m.clearedusers
	case group.EdgeFilters:
		return m.clearedfilters
	case group.EdgeApps:
		return m.clearedapps
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupMutation) ClearEdge(name string) error {
	switch name {
	case group.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Group unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupMutation) ResetEdge(name string) error {
	switch name {
	case group.EdgeTenant:
		m.ResetTenant()
		return nil
	case group.EdgeTransportRecipients:
		m.ResetTransportRecipients()
		return nil
	case group.EdgeUsers:
		m.ResetUsers()
		return nil
	case group.EdgeFilters:
		m.ResetFilters()
		return nil
	case group.EdgeApps:
		m.ResetApps()
		return nil
	}
	return fmt.Errorf("unknown Group edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	_Message      *string
	_ShortMsg     *string
	_Topic        *string
	_Severity     *int
	add_Severity  *int
	_Timestamp    *time.Time
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	vars          map[int]struct{}
	removedvars   map[int]struct{}
	clearedvars   bool
	app           *int
	clearedapp    bool
	done          bool
	oldValue      func(context.Context) (*Message, error)
	predicates    []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id uuid.UUID) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Message entities.
func (m *MessageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Message.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *MessageMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *MessageMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *MessageMutation) ResetTenantID() {
	m.tenant = nil
}

// SetMessage sets the "Message" field.
func (m *MessageMutation) SetMessage(s string) {
	m._Message = &s
}

// Message returns the value of the "Message" field in the mutation.
func (m *MessageMutation) Message() (r string, exists bool) {
	v := m._Message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "Message" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "Message" field.
func (m *MessageMutation) ResetMessage() {
	m._Message = nil
}

// SetShortMsg sets the "ShortMsg" field.
func (m *MessageMutation) SetShortMsg(s string) {
	m._ShortMsg = &s
}

// ShortMsg returns the value of the "ShortMsg" field in the mutation.
func (m *MessageMutation) ShortMsg() (r string, exists bool) {
	v := m._ShortMsg
	if v == nil {
		return
	}
	return *v, true
}

// OldShortMsg returns the old "ShortMsg" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldShortMsg(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShortMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShortMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShortMsg: %w", err)
	}
	return oldValue.ShortMsg, nil
}

// ClearShortMsg clears the value of the "ShortMsg" field.
func (m *MessageMutation) ClearShortMsg() {
	m._ShortMsg = nil
	m.clearedFields[message.FieldShortMsg] = struct{}{}
}

// ShortMsgCleared returns if the "ShortMsg" field was cleared in this mutation.
func (m *MessageMutation) ShortMsgCleared() bool {
	_, ok := m.clearedFields[message.FieldShortMsg]
	return ok
}

// ResetShortMsg resets all changes to the "ShortMsg" field.
func (m *MessageMutation) ResetShortMsg() {
	m._ShortMsg = nil
	delete(m.clearedFields, message.FieldShortMsg)
}

// SetTopic sets the "Topic" field.
func (m *MessageMutation) SetTopic(s string) {
	m._Topic = &s
}

// Topic returns the value of the "Topic" field in the mutation.
func (m *MessageMutation) Topic() (r string, exists bool) {
	v := m._Topic
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic returns the old "Topic" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldTopic(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic: %w", err)
	}
	return oldValue.Topic, nil
}

// ClearTopic clears the value of the "Topic" field.
func (m *MessageMutation) ClearTopic() {
	m._Topic = nil
	m.clearedFields[message.FieldTopic] = struct{}{}
}

// TopicCleared returns if the "Topic" field was cleared in this mutation.
func (m *MessageMutation) TopicCleared() bool {
	_, ok := m.clearedFields[message.FieldTopic]
	return ok
}

// ResetTopic resets all changes to the "Topic" field.
func (m *MessageMutation) ResetTopic() {
	m._Topic = nil
	delete(m.clearedFields, message.FieldTopic)
}

// SetSeverity sets the "Severity" field.
func (m *MessageMutation) SetSeverity(i int) {
	m._Severity = &i
	m.add_Severity = nil
}

// Severity returns the value of the "Severity" field in the mutation.
func (m *MessageMutation) Severity() (r int, exists bool) {
	v := m._Severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "Severity" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldSeverity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// AddSeverity adds i to the "Severity" field.
func (m *MessageMutation) AddSeverity(i int) {
	if m.add_Severity != nil {
		*m.add_Severity += i
	} else {
		m.add_Severity = &i
	}
}

// AddedSeverity returns the value that was added to the "Severity" field in this mutation.
func (m *MessageMutation) AddedSeverity() (r int, exists bool) {
	v := m.add_Severity
	if v == nil {
		return
	}
	return *v, true
}

// ClearSeverity clears the value of the "Severity" field.
func (m *MessageMutation) ClearSeverity() {
	m._Severity = nil
	m.add_Severity = nil
	m.clearedFields[message.FieldSeverity] = struct{}{}
}

// SeverityCleared returns if the "Severity" field was cleared in this mutation.
func (m *MessageMutation) SeverityCleared() bool {
	_, ok := m.clearedFields[message.FieldSeverity]
	return ok
}

// ResetSeverity resets all changes to the "Severity" field.
func (m *MessageMutation) ResetSeverity() {
	m._Severity = nil
	m.add_Severity = nil
	delete(m.clearedFields, message.FieldSeverity)
}

// SetTimestamp sets the "Timestamp" field.
func (m *MessageMutation) SetTimestamp(t time.Time) {
	m._Timestamp = &t
}

// Timestamp returns the value of the "Timestamp" field in the mutation.
func (m *MessageMutation) Timestamp() (r time.Time, exists bool) {
	v := m._Timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "Timestamp" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "Timestamp" field.
func (m *MessageMutation) ResetTimestamp() {
	m._Timestamp = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *MessageMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *MessageMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *MessageMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddVarIDs adds the "vars" edge to the MsgVar entity by ids.
func (m *MessageMutation) AddVarIDs(ids ...int) {
	if m.vars == nil {
		m.vars = make(map[int]struct{})
	}
	for i := range ids {
		m.vars[ids[i]] = struct{}{}
	}
}

// ClearVars clears the "vars" edge to the MsgVar entity.
func (m *MessageMutation) ClearVars() {
	m.clearedvars = true
}

// VarsCleared reports if the "vars" edge to the MsgVar entity was cleared.
func (m *MessageMutation) VarsCleared() bool {
	return m.clearedvars
}

// RemoveVarIDs removes the "vars" edge to the MsgVar entity by IDs.
func (m *MessageMutation) RemoveVarIDs(ids ...int) {
	if m.removedvars == nil {
		m.removedvars = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vars, ids[i])
		m.removedvars[ids[i]] = struct{}{}
	}
}

// RemovedVars returns the removed IDs of the "vars" edge to the MsgVar entity.
func (m *MessageMutation) RemovedVarsIDs() (ids []int) {
	for id := range m.removedvars {
		ids = append(ids, id)
	}
	return
}

// VarsIDs returns the "vars" edge IDs in the mutation.
func (m *MessageMutation) VarsIDs() (ids []int) {
	for id := range m.vars {
		ids = append(ids, id)
	}
	return
}

// ResetVars resets all changes to the "vars" edge.
func (m *MessageMutation) ResetVars() {
	m.vars = nil
	m.clearedvars = false
	m.removedvars = nil
}

// SetAppID sets the "app" edge to the App entity by id.
func (m *MessageMutation) SetAppID(id int) {
	m.app = &id
}

// ClearApp clears the "app" edge to the App entity.
func (m *MessageMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *MessageMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the "app" edge ID in the mutation.
func (m *MessageMutation) AppID() (id int, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *MessageMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.tenant != nil {
		fields = append(fields, message.FieldTenantID)
	}
	if m._Message != nil {
		fields = append(fields, message.FieldMessage)
	}
	if m._ShortMsg != nil {
		fields = append(fields, message.FieldShortMsg)
	}
	if m._Topic != nil {
		fields = append(fields, message.FieldTopic)
	}
	if m._Severity != nil {
		fields = append(fields, message.FieldSeverity)
	}
	if m._Timestamp != nil {
		fields = append(fields, message.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldTenantID:
		return m.TenantID()
	case message.FieldMessage:
		return m.Message()
	case message.FieldShortMsg:
		return m.ShortMsg()
	case message.FieldTopic:
		return m.Topic()
	case message.FieldSeverity:
		return m.Severity()
	case message.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldTenantID:
		return m.OldTenantID(ctx)
	case message.FieldMessage:
		return m.OldMessage(ctx)
	case message.FieldShortMsg:
		return m.OldShortMsg(ctx)
	case message.FieldTopic:
		return m.OldTopic(ctx)
	case message.FieldSeverity:
		return m.OldSeverity(ctx)
	case message.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case message.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case message.FieldShortMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShortMsg(v)
		return nil
	case message.FieldTopic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic(v)
		return nil
	case message.FieldSeverity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case message.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	var fields []string
	if m.add_Severity != nil {
		fields = append(fields, message.FieldSeverity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case message.FieldSeverity:
		return m.AddedSeverity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case message.FieldSeverity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeverity(v)
		return nil
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(message.FieldShortMsg) {
		fields = append(fields, message.FieldShortMsg)
	}
	if m.FieldCleared(message.FieldTopic) {
		fields = append(fields, message.FieldTopic)
	}
	if m.FieldCleared(message.FieldSeverity) {
		fields = append(fields, message.FieldSeverity)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	switch name {
	case message.FieldShortMsg:
		m.ClearShortMsg()
		return nil
	case message.FieldTopic:
		m.ClearTopic()
		return nil
	case message.FieldSeverity:
		m.ClearSeverity()
		return nil
	}
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldTenantID:
		m.ResetTenantID()
		return nil
	case message.FieldMessage:
		m.ResetMessage()
		return nil
	case message.FieldShortMsg:
		m.ResetShortMsg()
		return nil
	case message.FieldTopic:
		m.ResetTopic()
		return nil
	case message.FieldSeverity:
		m.ResetSeverity()
		return nil
	case message.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, message.EdgeTenant)
	}
	if m.vars != nil {
		edges = append(edges, message.EdgeVars)
	}
	if m.app != nil {
		edges = append(edges, message.EdgeApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case message.EdgeVars:
		ids := make([]ent.Value, 0, len(m.vars))
		for id := range m.vars {
			ids = append(ids, id)
		}
		return ids
	case message.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedvars != nil {
		edges = append(edges, message.EdgeVars)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeVars:
		ids := make([]ent.Value, 0, len(m.removedvars))
		for id := range m.removedvars {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, message.EdgeTenant)
	}
	if m.clearedvars {
		edges = append(edges, message.EdgeVars)
	}
	if m.clearedapp {
		edges = append(edges, message.EdgeApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	switch name {
	case message.EdgeTenant:
		return m.clearedtenant
	case message.EdgeVars:
		return m.clearedvars
	case message.EdgeApp:
		return m.clearedapp
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	switch name {
	case message.EdgeTenant:
		m.ClearTenant()
		return nil
	case message.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	switch name {
	case message.EdgeTenant:
		m.ResetTenant()
		return nil
	case message.EdgeVars:
		m.ResetVars()
		return nil
	case message.EdgeApp:
		m.ResetApp()
		return nil
	}
	return fmt.Errorf("unknown Message edge %s", name)
}

// MsgVarMutation represents an operation that mutates the MsgVar nodes in the graph.
type MsgVarMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Name         *string
	_Value        *string
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	owner         *uuid.UUID
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*MsgVar, error)
	predicates    []predicate.MsgVar
}

var _ ent.Mutation = (*MsgVarMutation)(nil)

// msgvarOption allows management of the mutation configuration using functional options.
type msgvarOption func(*MsgVarMutation)

// newMsgVarMutation creates new mutation for the MsgVar entity.
func newMsgVarMutation(c config, op Op, opts ...msgvarOption) *MsgVarMutation {
	m := &MsgVarMutation{
		config:        c,
		op:            op,
		typ:           TypeMsgVar,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMsgVarID sets the ID field of the mutation.
func withMsgVarID(id int) msgvarOption {
	return func(m *MsgVarMutation) {
		var (
			err   error
			once  sync.Once
			value *MsgVar
		)
		m.oldValue = func(ctx context.Context) (*MsgVar, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MsgVar.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMsgVar sets the old MsgVar of the mutation.
func withMsgVar(node *MsgVar) msgvarOption {
	return func(m *MsgVarMutation) {
		m.oldValue = func(context.Context) (*MsgVar, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MsgVarMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MsgVarMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MsgVarMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MsgVarMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MsgVar.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *MsgVarMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *MsgVarMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the MsgVar entity.
// If the MsgVar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MsgVarMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *MsgVarMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "Name" field.
func (m *MsgVarMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *MsgVarMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the MsgVar entity.
// If the MsgVar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MsgVarMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *MsgVarMutation) ResetName() {
	m._Name = nil
}

// SetValue sets the "Value" field.
func (m *MsgVarMutation) SetValue(s string) {
	m._Value = &s
}

// Value returns the value of the "Value" field in the mutation.
func (m *MsgVarMutation) Value() (r string, exists bool) {
	v := m._Value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "Value" field's value of the MsgVar entity.
// If the MsgVar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MsgVarMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "Value" field.
func (m *MsgVarMutation) ResetValue() {
	m._Value = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *MsgVarMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *MsgVarMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *MsgVarMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *MsgVarMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetOwnerID sets the "owner" edge to the Message entity by id.
func (m *MsgVarMutation) SetOwnerID(id uuid.UUID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Message entity.
func (m *MsgVarMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Message entity was cleared.
func (m *MsgVarMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *MsgVarMutation) OwnerID() (id uuid.UUID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *MsgVarMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *MsgVarMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the MsgVarMutation builder.
func (m *MsgVarMutation) Where(ps ...predicate.MsgVar) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MsgVarMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MsgVar).
func (m *MsgVarMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MsgVarMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tenant != nil {
		fields = append(fields, msgvar.FieldTenantID)
	}
	if m._Name != nil {
		fields = append(fields, msgvar.FieldName)
	}
	if m._Value != nil {
		fields = append(fields, msgvar.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MsgVarMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case msgvar.FieldTenantID:
		return m.TenantID()
	case msgvar.FieldName:
		return m.Name()
	case msgvar.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MsgVarMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case msgvar.FieldTenantID:
		return m.OldTenantID(ctx)
	case msgvar.FieldName:
		return m.OldName(ctx)
	case msgvar.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown MsgVar field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MsgVarMutation) SetField(name string, value ent.Value) error {
	switch name {
	case msgvar.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case msgvar.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case msgvar.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown MsgVar field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MsgVarMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MsgVarMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MsgVarMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MsgVar numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MsgVarMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MsgVarMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MsgVarMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MsgVar nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MsgVarMutation) ResetField(name string) error {
	switch name {
	case msgvar.FieldTenantID:
		m.ResetTenantID()
		return nil
	case msgvar.FieldName:
		m.ResetName()
		return nil
	case msgvar.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown MsgVar field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MsgVarMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, msgvar.EdgeTenant)
	}
	if m.owner != nil {
		edges = append(edges, msgvar.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MsgVarMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case msgvar.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case msgvar.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MsgVarMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MsgVarMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MsgVarMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, msgvar.EdgeTenant)
	}
	if m.clearedowner {
		edges = append(edges, msgvar.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MsgVarMutation) EdgeCleared(name string) bool {
	switch name {
	case msgvar.EdgeTenant:
		return m.clearedtenant
	case msgvar.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MsgVarMutation) ClearEdge(name string) error {
	switch name {
	case msgvar.EdgeTenant:
		m.ClearTenant()
		return nil
	case msgvar.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown MsgVar unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MsgVarMutation) ResetEdge(name string) error {
	switch name {
	case msgvar.EdgeTenant:
		m.ResetTenant()
		return nil
	case msgvar.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown MsgVar edge %s", name)
}

// TenantMutation represents an operation that mutates the Tenant nodes in the graph.
type TenantMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Tenant, error)
	predicates    []predicate.Tenant
}

var _ ent.Mutation = (*TenantMutation)(nil)

// tenantOption allows management of the mutation configuration using functional options.
type tenantOption func(*TenantMutation)

// newTenantMutation creates new mutation for the Tenant entity.
func newTenantMutation(c config, op Op, opts ...tenantOption) *TenantMutation {
	m := &TenantMutation{
		config:        c,
		op:            op,
		typ:           TypeTenant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantID sets the ID field of the mutation.
func withTenantID(id int) tenantOption {
	return func(m *TenantMutation) {
		var (
			err   error
			once  sync.Once
			value *Tenant
		)
		m.oldValue = func(ctx context.Context) (*Tenant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tenant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenant sets the old Tenant of the mutation.
func withTenant(node *Tenant) tenantOption {
	return func(m *TenantMutation) {
		m.oldValue = func(context.Context) (*Tenant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tenant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TenantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TenantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TenantMutation) ResetName() {
	m.name = nil
}

// Where appends a list predicates to the TenantMutation builder.
func (m *TenantMutation) Where(ps ...predicate.Tenant) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TenantMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tenant).
func (m *TenantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, tenant.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenant.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Tenant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tenant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tenant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantMutation) ResetField(name string) error {
	switch name {
	case tenant.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Tenant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Tenant edge %s", name)
}

// TransportInstanceMutation represents an operation that mutates the TransportInstance nodes in the graph.
type TransportInstanceMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	_Name                       *string
	_Description                *string
	clearedFields               map[string]struct{}
	tenant                      *int
	clearedtenant               bool
	_TransportRecipients        map[int]struct{}
	removed_TransportRecipients map[int]struct{}
	cleared_TransportRecipients bool
	done                        bool
	oldValue                    func(context.Context) (*TransportInstance, error)
	predicates                  []predicate.TransportInstance
}

var _ ent.Mutation = (*TransportInstanceMutation)(nil)

// transportinstanceOption allows management of the mutation configuration using functional options.
type transportinstanceOption func(*TransportInstanceMutation)

// newTransportInstanceMutation creates new mutation for the TransportInstance entity.
func newTransportInstanceMutation(c config, op Op, opts ...transportinstanceOption) *TransportInstanceMutation {
	m := &TransportInstanceMutation{
		config:        c,
		op:            op,
		typ:           TypeTransportInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransportInstanceID sets the ID field of the mutation.
func withTransportInstanceID(id int) transportinstanceOption {
	return func(m *TransportInstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *TransportInstance
		)
		m.oldValue = func(ctx context.Context) (*TransportInstance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TransportInstance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransportInstance sets the old TransportInstance of the mutation.
func withTransportInstance(node *TransportInstance) transportinstanceOption {
	return func(m *TransportInstanceMutation) {
		m.oldValue = func(context.Context) (*TransportInstance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransportInstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransportInstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransportInstanceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransportInstanceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TransportInstance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *TransportInstanceMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TransportInstanceMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TransportInstance entity.
// If the TransportInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransportInstanceMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TransportInstanceMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "Name" field.
func (m *TransportInstanceMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *TransportInstanceMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the TransportInstance entity.
// If the TransportInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransportInstanceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *TransportInstanceMutation) ResetName() {
	m._Name = nil
}

// SetDescription sets the "Description" field.
func (m *TransportInstanceMutation) SetDescription(s string) {
	m._Description = &s
}

// Description returns the value of the "Description" field in the mutation.
func (m *TransportInstanceMutation) Description() (r string, exists bool) {
	v := m._Description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "Description" field's value of the TransportInstance entity.
// If the TransportInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransportInstanceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "Description" field.
func (m *TransportInstanceMutation) ResetDescription() {
	m._Description = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *TransportInstanceMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *TransportInstanceMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *TransportInstanceMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *TransportInstanceMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddTransportRecipientIDs adds the "TransportRecipients" edge to the TransportRecipient entity by ids.
func (m *TransportInstanceMutation) AddTransportRecipientIDs(ids ...int) {
	if m._TransportRecipients == nil {
		m._TransportRecipients = make(map[int]struct{})
	}
	for i := range ids {
		m._TransportRecipients[ids[i]] = struct{}{}
	}
}

// ClearTransportRecipients clears the "TransportRecipients" edge to the TransportRecipient entity.
func (m *TransportInstanceMutation) ClearTransportRecipients() {
	m.cleared_TransportRecipients = true
}

// TransportRecipientsCleared reports if the "TransportRecipients" edge to the TransportRecipient entity was cleared.
func (m *TransportInstanceMutation) TransportRecipientsCleared() bool {
	return m.cleared_TransportRecipients
}

// RemoveTransportRecipientIDs removes the "TransportRecipients" edge to the TransportRecipient entity by IDs.
func (m *TransportInstanceMutation) RemoveTransportRecipientIDs(ids ...int) {
	if m.removed_TransportRecipients == nil {
		m.removed_TransportRecipients = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._TransportRecipients, ids[i])
		m.removed_TransportRecipients[ids[i]] = struct{}{}
	}
}

// RemovedTransportRecipients returns the removed IDs of the "TransportRecipients" edge to the TransportRecipient entity.
func (m *TransportInstanceMutation) RemovedTransportRecipientsIDs() (ids []int) {
	for id := range m.removed_TransportRecipients {
		ids = append(ids, id)
	}
	return
}

// TransportRecipientsIDs returns the "TransportRecipients" edge IDs in the mutation.
func (m *TransportInstanceMutation) TransportRecipientsIDs() (ids []int) {
	for id := range m._TransportRecipients {
		ids = append(ids, id)
	}
	return
}

// ResetTransportRecipients resets all changes to the "TransportRecipients" edge.
func (m *TransportInstanceMutation) ResetTransportRecipients() {
	m._TransportRecipients = nil
	m.cleared_TransportRecipients = false
	m.removed_TransportRecipients = nil
}

// Where appends a list predicates to the TransportInstanceMutation builder.
func (m *TransportInstanceMutation) Where(ps ...predicate.TransportInstance) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TransportInstanceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TransportInstance).
func (m *TransportInstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransportInstanceMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tenant != nil {
		fields = append(fields, transportinstance.FieldTenantID)
	}
	if m._Name != nil {
		fields = append(fields, transportinstance.FieldName)
	}
	if m._Description != nil {
		fields = append(fields, transportinstance.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransportInstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transportinstance.FieldTenantID:
		return m.TenantID()
	case transportinstance.FieldName:
		return m.Name()
	case transportinstance.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransportInstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transportinstance.FieldTenantID:
		return m.OldTenantID(ctx)
	case transportinstance.FieldName:
		return m.OldName(ctx)
	case transportinstance.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown TransportInstance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransportInstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transportinstance.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case transportinstance.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case transportinstance.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown TransportInstance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransportInstanceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransportInstanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransportInstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TransportInstance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransportInstanceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransportInstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransportInstanceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TransportInstance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransportInstanceMutation) ResetField(name string) error {
	switch name {
	case transportinstance.FieldTenantID:
		m.ResetTenantID()
		return nil
	case transportinstance.FieldName:
		m.ResetName()
		return nil
	case transportinstance.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown TransportInstance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransportInstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, transportinstance.EdgeTenant)
	}
	if m._TransportRecipients != nil {
		edges = append(edges, transportinstance.EdgeTransportRecipients)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransportInstanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transportinstance.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case transportinstance.EdgeTransportRecipients:
		ids := make([]ent.Value, 0, len(m._TransportRecipients))
		for id := range m._TransportRecipients {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransportInstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_TransportRecipients != nil {
		edges = append(edges, transportinstance.EdgeTransportRecipients)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransportInstanceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transportinstance.EdgeTransportRecipients:
		ids := make([]ent.Value, 0, len(m.removed_TransportRecipients))
		for id := range m.removed_TransportRecipients {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransportInstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, transportinstance.EdgeTenant)
	}
	if m.cleared_TransportRecipients {
		edges = append(edges, transportinstance.EdgeTransportRecipients)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransportInstanceMutation) EdgeCleared(name string) bool {
	switch name {
	case transportinstance.EdgeTenant:
		return m.clearedtenant
	case transportinstance.EdgeTransportRecipients:
		return m.cleared_TransportRecipients
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransportInstanceMutation) ClearEdge(name string) error {
	switch name {
	case transportinstance.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown TransportInstance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransportInstanceMutation) ResetEdge(name string) error {
	switch name {
	case transportinstance.EdgeTenant:
		m.ResetTenant()
		return nil
	case transportinstance.EdgeTransportRecipients:
		m.ResetTransportRecipients()
		return nil
	}
	return fmt.Errorf("unknown TransportInstance edge %s", name)
}

// TransportRecipientMutation represents an operation that mutates the TransportRecipient nodes in the graph.
type TransportRecipientMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	_Name                     *string
	_Description              *string
	clearedFields             map[string]struct{}
	tenant                    *int
	clearedtenant             bool
	_TransportInstance        *int
	cleared_TransportInstance bool
	_AppRecipient             map[int]struct{}
	removed_AppRecipient      map[int]struct{}
	cleared_AppRecipient      bool
	_GroupRecipient           map[int]struct{}
	removed_GroupRecipient    map[int]struct{}
	cleared_GroupRecipient    bool
	_UserRecipient            map[int]struct{}
	removed_UserRecipient     map[int]struct{}
	cleared_UserRecipient     bool
	done                      bool
	oldValue                  func(context.Context) (*TransportRecipient, error)
	predicates                []predicate.TransportRecipient
}

var _ ent.Mutation = (*TransportRecipientMutation)(nil)

// transportrecipientOption allows management of the mutation configuration using functional options.
type transportrecipientOption func(*TransportRecipientMutation)

// newTransportRecipientMutation creates new mutation for the TransportRecipient entity.
func newTransportRecipientMutation(c config, op Op, opts ...transportrecipientOption) *TransportRecipientMutation {
	m := &TransportRecipientMutation{
		config:        c,
		op:            op,
		typ:           TypeTransportRecipient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransportRecipientID sets the ID field of the mutation.
func withTransportRecipientID(id int) transportrecipientOption {
	return func(m *TransportRecipientMutation) {
		var (
			err   error
			once  sync.Once
			value *TransportRecipient
		)
		m.oldValue = func(ctx context.Context) (*TransportRecipient, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TransportRecipient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransportRecipient sets the old TransportRecipient of the mutation.
func withTransportRecipient(node *TransportRecipient) transportrecipientOption {
	return func(m *TransportRecipientMutation) {
		m.oldValue = func(context.Context) (*TransportRecipient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransportRecipientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransportRecipientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransportRecipientMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransportRecipientMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TransportRecipient.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *TransportRecipientMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TransportRecipientMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TransportRecipient entity.
// If the TransportRecipient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransportRecipientMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TransportRecipientMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "Name" field.
func (m *TransportRecipientMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *TransportRecipientMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the TransportRecipient entity.
// If the TransportRecipient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransportRecipientMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *TransportRecipientMutation) ResetName() {
	m._Name = nil
}

// SetDescription sets the "Description" field.
func (m *TransportRecipientMutation) SetDescription(s string) {
	m._Description = &s
}

// Description returns the value of the "Description" field in the mutation.
func (m *TransportRecipientMutation) Description() (r string, exists bool) {
	v := m._Description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "Description" field's value of the TransportRecipient entity.
// If the TransportRecipient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransportRecipientMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "Description" field.
func (m *TransportRecipientMutation) ResetDescription() {
	m._Description = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *TransportRecipientMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *TransportRecipientMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *TransportRecipientMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *TransportRecipientMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetTransportInstanceID sets the "TransportInstance" edge to the TransportInstance entity by id.
func (m *TransportRecipientMutation) SetTransportInstanceID(id int) {
	m._TransportInstance = &id
}

// ClearTransportInstance clears the "TransportInstance" edge to the TransportInstance entity.
func (m *TransportRecipientMutation) ClearTransportInstance() {
	m.cleared_TransportInstance = true
}

// TransportInstanceCleared reports if the "TransportInstance" edge to the TransportInstance entity was cleared.
func (m *TransportRecipientMutation) TransportInstanceCleared() bool {
	return m.cleared_TransportInstance
}

// TransportInstanceID returns the "TransportInstance" edge ID in the mutation.
func (m *TransportRecipientMutation) TransportInstanceID() (id int, exists bool) {
	if m._TransportInstance != nil {
		return *m._TransportInstance, true
	}
	return
}

// TransportInstanceIDs returns the "TransportInstance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransportInstanceID instead. It exists only for internal usage by the builders.
func (m *TransportRecipientMutation) TransportInstanceIDs() (ids []int) {
	if id := m._TransportInstance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransportInstance resets all changes to the "TransportInstance" edge.
func (m *TransportRecipientMutation) ResetTransportInstance() {
	m._TransportInstance = nil
	m.cleared_TransportInstance = false
}

// AddAppRecipientIDs adds the "AppRecipient" edge to the App entity by ids.
func (m *TransportRecipientMutation) AddAppRecipientIDs(ids ...int) {
	if m._AppRecipient == nil {
		m._AppRecipient = make(map[int]struct{})
	}
	for i := range ids {
		m._AppRecipient[ids[i]] = struct{}{}
	}
}

// ClearAppRecipient clears the "AppRecipient" edge to the App entity.
func (m *TransportRecipientMutation) ClearAppRecipient() {
	m.cleared_AppRecipient = true
}

// AppRecipientCleared reports if the "AppRecipient" edge to the App entity was cleared.
func (m *TransportRecipientMutation) AppRecipientCleared() bool {
	return m.cleared_AppRecipient
}

// RemoveAppRecipientIDs removes the "AppRecipient" edge to the App entity by IDs.
func (m *TransportRecipientMutation) RemoveAppRecipientIDs(ids ...int) {
	if m.removed_AppRecipient == nil {
		m.removed_AppRecipient = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._AppRecipient, ids[i])
		m.removed_AppRecipient[ids[i]] = struct{}{}
	}
}

// RemovedAppRecipient returns the removed IDs of the "AppRecipient" edge to the App entity.
func (m *TransportRecipientMutation) RemovedAppRecipientIDs() (ids []int) {
	for id := range m.removed_AppRecipient {
		ids = append(ids, id)
	}
	return
}

// AppRecipientIDs returns the "AppRecipient" edge IDs in the mutation.
func (m *TransportRecipientMutation) AppRecipientIDs() (ids []int) {
	for id := range m._AppRecipient {
		ids = append(ids, id)
	}
	return
}

// ResetAppRecipient resets all changes to the "AppRecipient" edge.
func (m *TransportRecipientMutation) ResetAppRecipient() {
	m._AppRecipient = nil
	m.cleared_AppRecipient = false
	m.removed_AppRecipient = nil
}

// AddGroupRecipientIDs adds the "GroupRecipient" edge to the Group entity by ids.
func (m *TransportRecipientMutation) AddGroupRecipientIDs(ids ...int) {
	if m._GroupRecipient == nil {
		m._GroupRecipient = make(map[int]struct{})
	}
	for i := range ids {
		m._GroupRecipient[ids[i]] = struct{}{}
	}
}

// ClearGroupRecipient clears the "GroupRecipient" edge to the Group entity.
func (m *TransportRecipientMutation) ClearGroupRecipient() {
	m.cleared_GroupRecipient = true
}

// GroupRecipientCleared reports if the "GroupRecipient" edge to the Group entity was cleared.
func (m *TransportRecipientMutation) GroupRecipientCleared() bool {
	return m.cleared_GroupRecipient
}

// RemoveGroupRecipientIDs removes the "GroupRecipient" edge to the Group entity by IDs.
func (m *TransportRecipientMutation) RemoveGroupRecipientIDs(ids ...int) {
	if m.removed_GroupRecipient == nil {
		m.removed_GroupRecipient = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._GroupRecipient, ids[i])
		m.removed_GroupRecipient[ids[i]] = struct{}{}
	}
}

// RemovedGroupRecipient returns the removed IDs of the "GroupRecipient" edge to the Group entity.
func (m *TransportRecipientMutation) RemovedGroupRecipientIDs() (ids []int) {
	for id := range m.removed_GroupRecipient {
		ids = append(ids, id)
	}
	return
}

// GroupRecipientIDs returns the "GroupRecipient" edge IDs in the mutation.
func (m *TransportRecipientMutation) GroupRecipientIDs() (ids []int) {
	for id := range m._GroupRecipient {
		ids = append(ids, id)
	}
	return
}

// ResetGroupRecipient resets all changes to the "GroupRecipient" edge.
func (m *TransportRecipientMutation) ResetGroupRecipient() {
	m._GroupRecipient = nil
	m.cleared_GroupRecipient = false
	m.removed_GroupRecipient = nil
}

// AddUserRecipientIDs adds the "UserRecipient" edge to the User entity by ids.
func (m *TransportRecipientMutation) AddUserRecipientIDs(ids ...int) {
	if m._UserRecipient == nil {
		m._UserRecipient = make(map[int]struct{})
	}
	for i := range ids {
		m._UserRecipient[ids[i]] = struct{}{}
	}
}

// ClearUserRecipient clears the "UserRecipient" edge to the User entity.
func (m *TransportRecipientMutation) ClearUserRecipient() {
	m.cleared_UserRecipient = true
}

// UserRecipientCleared reports if the "UserRecipient" edge to the User entity was cleared.
func (m *TransportRecipientMutation) UserRecipientCleared() bool {
	return m.cleared_UserRecipient
}

// RemoveUserRecipientIDs removes the "UserRecipient" edge to the User entity by IDs.
func (m *TransportRecipientMutation) RemoveUserRecipientIDs(ids ...int) {
	if m.removed_UserRecipient == nil {
		m.removed_UserRecipient = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._UserRecipient, ids[i])
		m.removed_UserRecipient[ids[i]] = struct{}{}
	}
}

// RemovedUserRecipient returns the removed IDs of the "UserRecipient" edge to the User entity.
func (m *TransportRecipientMutation) RemovedUserRecipientIDs() (ids []int) {
	for id := range m.removed_UserRecipient {
		ids = append(ids, id)
	}
	return
}

// UserRecipientIDs returns the "UserRecipient" edge IDs in the mutation.
func (m *TransportRecipientMutation) UserRecipientIDs() (ids []int) {
	for id := range m._UserRecipient {
		ids = append(ids, id)
	}
	return
}

// ResetUserRecipient resets all changes to the "UserRecipient" edge.
func (m *TransportRecipientMutation) ResetUserRecipient() {
	m._UserRecipient = nil
	m.cleared_UserRecipient = false
	m.removed_UserRecipient = nil
}

// Where appends a list predicates to the TransportRecipientMutation builder.
func (m *TransportRecipientMutation) Where(ps ...predicate.TransportRecipient) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TransportRecipientMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TransportRecipient).
func (m *TransportRecipientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransportRecipientMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tenant != nil {
		fields = append(fields, transportrecipient.FieldTenantID)
	}
	if m._Name != nil {
		fields = append(fields, transportrecipient.FieldName)
	}
	if m._Description != nil {
		fields = append(fields, transportrecipient.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransportRecipientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transportrecipient.FieldTenantID:
		return m.TenantID()
	case transportrecipient.FieldName:
		return m.Name()
	case transportrecipient.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransportRecipientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transportrecipient.FieldTenantID:
		return m.OldTenantID(ctx)
	case transportrecipient.FieldName:
		return m.OldName(ctx)
	case transportrecipient.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown TransportRecipient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransportRecipientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transportrecipient.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case transportrecipient.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case transportrecipient.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown TransportRecipient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransportRecipientMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransportRecipientMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransportRecipientMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TransportRecipient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransportRecipientMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransportRecipientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransportRecipientMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TransportRecipient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransportRecipientMutation) ResetField(name string) error {
	switch name {
	case transportrecipient.FieldTenantID:
		m.ResetTenantID()
		return nil
	case transportrecipient.FieldName:
		m.ResetName()
		return nil
	case transportrecipient.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown TransportRecipient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransportRecipientMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.tenant != nil {
		edges = append(edges, transportrecipient.EdgeTenant)
	}
	if m._TransportInstance != nil {
		edges = append(edges, transportrecipient.EdgeTransportInstance)
	}
	if m._AppRecipient != nil {
		edges = append(edges, transportrecipient.EdgeAppRecipient)
	}
	if m._GroupRecipient != nil {
		edges = append(edges, transportrecipient.EdgeGroupRecipient)
	}
	if m._UserRecipient != nil {
		edges = append(edges, transportrecipient.EdgeUserRecipient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransportRecipientMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transportrecipient.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case transportrecipient.EdgeTransportInstance:
		if id := m._TransportInstance; id != nil {
			return []ent.Value{*id}
		}
	case transportrecipient.EdgeAppRecipient:
		ids := make([]ent.Value, 0, len(m._AppRecipient))
		for id := range m._AppRecipient {
			ids = append(ids, id)
		}
		return ids
	case transportrecipient.EdgeGroupRecipient:
		ids := make([]ent.Value, 0, len(m._GroupRecipient))
		for id := range m._GroupRecipient {
			ids = append(ids, id)
		}
		return ids
	case transportrecipient.EdgeUserRecipient:
		ids := make([]ent.Value, 0, len(m._UserRecipient))
		for id := range m._UserRecipient {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransportRecipientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removed_AppRecipient != nil {
		edges = append(edges, transportrecipient.EdgeAppRecipient)
	}
	if m.removed_GroupRecipient != nil {
		edges = append(edges, transportrecipient.EdgeGroupRecipient)
	}
	if m.removed_UserRecipient != nil {
		edges = append(edges, transportrecipient.EdgeUserRecipient)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransportRecipientMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transportrecipient.EdgeAppRecipient:
		ids := make([]ent.Value, 0, len(m.removed_AppRecipient))
		for id := range m.removed_AppRecipient {
			ids = append(ids, id)
		}
		return ids
	case transportrecipient.EdgeGroupRecipient:
		ids := make([]ent.Value, 0, len(m.removed_GroupRecipient))
		for id := range m.removed_GroupRecipient {
			ids = append(ids, id)
		}
		return ids
	case transportrecipient.EdgeUserRecipient:
		ids := make([]ent.Value, 0, len(m.removed_UserRecipient))
		for id := range m.removed_UserRecipient {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransportRecipientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtenant {
		edges = append(edges, transportrecipient.EdgeTenant)
	}
	if m.cleared_TransportInstance {
		edges = append(edges, transportrecipient.EdgeTransportInstance)
	}
	if m.cleared_AppRecipient {
		edges = append(edges, transportrecipient.EdgeAppRecipient)
	}
	if m.cleared_GroupRecipient {
		edges = append(edges, transportrecipient.EdgeGroupRecipient)
	}
	if m.cleared_UserRecipient {
		edges = append(edges, transportrecipient.EdgeUserRecipient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransportRecipientMutation) EdgeCleared(name string) bool {
	switch name {
	case transportrecipient.EdgeTenant:
		return m.clearedtenant
	case transportrecipient.EdgeTransportInstance:
		return m.cleared_TransportInstance
	case transportrecipient.EdgeAppRecipient:
		return m.cleared_AppRecipient
	case transportrecipient.EdgeGroupRecipient:
		return m.cleared_GroupRecipient
	case transportrecipient.EdgeUserRecipient:
		return m.cleared_UserRecipient
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransportRecipientMutation) ClearEdge(name string) error {
	switch name {
	case transportrecipient.EdgeTenant:
		m.ClearTenant()
		return nil
	case transportrecipient.EdgeTransportInstance:
		m.ClearTransportInstance()
		return nil
	}
	return fmt.Errorf("unknown TransportRecipient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransportRecipientMutation) ResetEdge(name string) error {
	switch name {
	case transportrecipient.EdgeTenant:
		m.ResetTenant()
		return nil
	case transportrecipient.EdgeTransportInstance:
		m.ResetTransportInstance()
		return nil
	case transportrecipient.EdgeAppRecipient:
		m.ResetAppRecipient()
		return nil
	case transportrecipient.EdgeGroupRecipient:
		m.ResetGroupRecipient()
		return nil
	case transportrecipient.EdgeUserRecipient:
		m.ResetUserRecipient()
		return nil
	}
	return fmt.Errorf("unknown TransportRecipient edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	_Email                      *string
	_Name                       *string
	_Description                *string
	clearedFields               map[string]struct{}
	tenant                      *int
	clearedtenant               bool
	metadata                    map[int]struct{}
	removedmetadata             map[int]struct{}
	clearedmetadata             bool
	filters                     map[int]struct{}
	removedfilters              map[int]struct{}
	clearedfilters              bool
	groups                      map[int]struct{}
	removedgroups               map[int]struct{}
	clearedgroups               bool
	_TransportRecipients        map[int]struct{}
	removed_TransportRecipients map[int]struct{}
	cleared_TransportRecipients bool
	done                        bool
	oldValue                    func(context.Context) (*User, error)
	predicates                  []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *UserMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *UserMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *UserMutation) ResetTenantID() {
	m.tenant = nil
}

// SetEmail sets the "Email" field.
func (m *UserMutation) SetEmail(s string) {
	m._Email = &s
}

// Email returns the value of the "Email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m._Email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "Email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "Email" field.
func (m *UserMutation) ResetEmail() {
	m._Email = nil
}

// SetName sets the "Name" field.
func (m *UserMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *UserMutation) ResetName() {
	m._Name = nil
}

// SetDescription sets the "Description" field.
func (m *UserMutation) SetDescription(s string) {
	m._Description = &s
}

// Description returns the value of the "Description" field in the mutation.
func (m *UserMutation) Description() (r string, exists bool) {
	v := m._Description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "Description" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "Description" field.
func (m *UserMutation) ResetDescription() {
	m._Description = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *UserMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *UserMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *UserMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *UserMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddMetadatumIDs adds the "metadata" edge to the UserMetaData entity by ids.
func (m *UserMutation) AddMetadatumIDs(ids ...int) {
	if m.metadata == nil {
		m.metadata = make(map[int]struct{})
	}
	for i := range ids {
		m.metadata[ids[i]] = struct{}{}
	}
}

// ClearMetadata clears the "metadata" edge to the UserMetaData entity.
func (m *UserMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the UserMetaData entity was cleared.
func (m *UserMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// RemoveMetadatumIDs removes the "metadata" edge to the UserMetaData entity by IDs.
func (m *UserMutation) RemoveMetadatumIDs(ids ...int) {
	if m.removedmetadata == nil {
		m.removedmetadata = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.metadata, ids[i])
		m.removedmetadata[ids[i]] = struct{}{}
	}
}

// RemovedMetadata returns the removed IDs of the "metadata" edge to the UserMetaData entity.
func (m *UserMutation) RemovedMetadataIDs() (ids []int) {
	for id := range m.removedmetadata {
		ids = append(ids, id)
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
func (m *UserMutation) MetadataIDs() (ids []int) {
	for id := range m.metadata {
		ids = append(ids, id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *UserMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
	m.removedmetadata = nil
}

// AddFilterIDs adds the "filters" edge to the Filter entity by ids.
func (m *UserMutation) AddFilterIDs(ids ...int) {
	if m.filters == nil {
		m.filters = make(map[int]struct{})
	}
	for i := range ids {
		m.filters[ids[i]] = struct{}{}
	}
}

// ClearFilters clears the "filters" edge to the Filter entity.
func (m *UserMutation) ClearFilters() {
	m.clearedfilters = true
}

// FiltersCleared reports if the "filters" edge to the Filter entity was cleared.
func (m *UserMutation) FiltersCleared() bool {
	return m.clearedfilters
}

// RemoveFilterIDs removes the "filters" edge to the Filter entity by IDs.
func (m *UserMutation) RemoveFilterIDs(ids ...int) {
	if m.removedfilters == nil {
		m.removedfilters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.filters, ids[i])
		m.removedfilters[ids[i]] = struct{}{}
	}
}

// RemovedFilters returns the removed IDs of the "filters" edge to the Filter entity.
func (m *UserMutation) RemovedFiltersIDs() (ids []int) {
	for id := range m.removedfilters {
		ids = append(ids, id)
	}
	return
}

// FiltersIDs returns the "filters" edge IDs in the mutation.
func (m *UserMutation) FiltersIDs() (ids []int) {
	for id := range m.filters {
		ids = append(ids, id)
	}
	return
}

// ResetFilters resets all changes to the "filters" edge.
func (m *UserMutation) ResetFilters() {
	m.filters = nil
	m.clearedfilters = false
	m.removedfilters = nil
}

// AddGroupIDs adds the "groups" edge to the Group entity by ids.
func (m *UserMutation) AddGroupIDs(ids ...int) {
	if m.groups == nil {
		m.groups = make(map[int]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the "groups" edge to the Group entity.
func (m *UserMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared reports if the "groups" edge to the Group entity was cleared.
func (m *UserMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the "groups" edge to the Group entity by IDs.
func (m *UserMutation) RemoveGroupIDs(ids ...int) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.groups, ids[i])
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed IDs of the "groups" edge to the Group entity.
func (m *UserMutation) RemovedGroupsIDs() (ids []int) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the "groups" edge IDs in the mutation.
func (m *UserMutation) GroupsIDs() (ids []int) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups resets all changes to the "groups" edge.
func (m *UserMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// AddTransportRecipientIDs adds the "TransportRecipients" edge to the TransportRecipient entity by ids.
func (m *UserMutation) AddTransportRecipientIDs(ids ...int) {
	if m._TransportRecipients == nil {
		m._TransportRecipients = make(map[int]struct{})
	}
	for i := range ids {
		m._TransportRecipients[ids[i]] = struct{}{}
	}
}

// ClearTransportRecipients clears the "TransportRecipients" edge to the TransportRecipient entity.
func (m *UserMutation) ClearTransportRecipients() {
	m.cleared_TransportRecipients = true
}

// TransportRecipientsCleared reports if the "TransportRecipients" edge to the TransportRecipient entity was cleared.
func (m *UserMutation) TransportRecipientsCleared() bool {
	return m.cleared_TransportRecipients
}

// RemoveTransportRecipientIDs removes the "TransportRecipients" edge to the TransportRecipient entity by IDs.
func (m *UserMutation) RemoveTransportRecipientIDs(ids ...int) {
	if m.removed_TransportRecipients == nil {
		m.removed_TransportRecipients = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._TransportRecipients, ids[i])
		m.removed_TransportRecipients[ids[i]] = struct{}{}
	}
}

// RemovedTransportRecipients returns the removed IDs of the "TransportRecipients" edge to the TransportRecipient entity.
func (m *UserMutation) RemovedTransportRecipientsIDs() (ids []int) {
	for id := range m.removed_TransportRecipients {
		ids = append(ids, id)
	}
	return
}

// TransportRecipientsIDs returns the "TransportRecipients" edge IDs in the mutation.
func (m *UserMutation) TransportRecipientsIDs() (ids []int) {
	for id := range m._TransportRecipients {
		ids = append(ids, id)
	}
	return
}

// ResetTransportRecipients resets all changes to the "TransportRecipients" edge.
func (m *UserMutation) ResetTransportRecipients() {
	m._TransportRecipients = nil
	m.cleared_TransportRecipients = false
	m.removed_TransportRecipients = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.tenant != nil {
		fields = append(fields, user.FieldTenantID)
	}
	if m._Email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m._Name != nil {
		fields = append(fields, user.FieldName)
	}
	if m._Description != nil {
		fields = append(fields, user.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldTenantID:
		return m.TenantID()
	case user.FieldEmail:
		return m.Email()
	case user.FieldName:
		return m.Name()
	case user.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldTenantID:
		return m.OldTenantID(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldTenantID:
		m.ResetTenantID()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.tenant != nil {
		edges = append(edges, user.EdgeTenant)
	}
	if m.metadata != nil {
		edges = append(edges, user.EdgeMetadata)
	}
	if m.filters != nil {
		edges = append(edges, user.EdgeFilters)
	}
	if m.groups != nil {
		edges = append(edges, user.EdgeGroups)
	}
	if m._TransportRecipients != nil {
		edges = append(edges, user.EdgeTransportRecipients)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.metadata))
		for id := range m.metadata {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFilters:
		ids := make([]ent.Value, 0, len(m.filters))
		for id := range m.filters {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTransportRecipients:
		ids := make([]ent.Value, 0, len(m._TransportRecipients))
		for id := range m._TransportRecipients {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedmetadata != nil {
		edges = append(edges, user.EdgeMetadata)
	}
	if m.removedfilters != nil {
		edges = append(edges, user.EdgeFilters)
	}
	if m.removedgroups != nil {
		edges = append(edges, user.EdgeGroups)
	}
	if m.removed_TransportRecipients != nil {
		edges = append(edges, user.EdgeTransportRecipients)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.removedmetadata))
		for id := range m.removedmetadata {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFilters:
		ids := make([]ent.Value, 0, len(m.removedfilters))
		for id := range m.removedfilters {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTransportRecipients:
		ids := make([]ent.Value, 0, len(m.removed_TransportRecipients))
		for id := range m.removed_TransportRecipients {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtenant {
		edges = append(edges, user.EdgeTenant)
	}
	if m.clearedmetadata {
		edges = append(edges, user.EdgeMetadata)
	}
	if m.clearedfilters {
		edges = append(edges, user.EdgeFilters)
	}
	if m.clearedgroups {
		edges = append(edges, user.EdgeGroups)
	}
	if m.cleared_TransportRecipients {
		edges = append(edges, user.EdgeTransportRecipients)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeTenant:
		return m.clearedtenant
	case user.EdgeMetadata:
		return m.clearedmetadata
	case user.EdgeFilters:
		return m.clearedfilters
	case user.EdgeGroups:
		return m.clearedgroups
	case user.EdgeTransportRecipients:
		return m.cleared_TransportRecipients
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeTenant:
		m.ResetTenant()
		return nil
	case user.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case user.EdgeFilters:
		m.ResetFilters()
		return nil
	case user.EdgeGroups:
		m.ResetGroups()
		return nil
	case user.EdgeTransportRecipients:
		m.ResetTransportRecipients()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserMetaDataMutation represents an operation that mutates the UserMetaData nodes in the graph.
type UserMetaDataMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Name         *string
	_Value        *string
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserMetaData, error)
	predicates    []predicate.UserMetaData
}

var _ ent.Mutation = (*UserMetaDataMutation)(nil)

// usermetadataOption allows management of the mutation configuration using functional options.
type usermetadataOption func(*UserMetaDataMutation)

// newUserMetaDataMutation creates new mutation for the UserMetaData entity.
func newUserMetaDataMutation(c config, op Op, opts ...usermetadataOption) *UserMetaDataMutation {
	m := &UserMetaDataMutation{
		config:        c,
		op:            op,
		typ:           TypeUserMetaData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserMetaDataID sets the ID field of the mutation.
func withUserMetaDataID(id int) usermetadataOption {
	return func(m *UserMetaDataMutation) {
		var (
			err   error
			once  sync.Once
			value *UserMetaData
		)
		m.oldValue = func(ctx context.Context) (*UserMetaData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserMetaData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserMetaData sets the old UserMetaData of the mutation.
func withUserMetaData(node *UserMetaData) usermetadataOption {
	return func(m *UserMetaDataMutation) {
		m.oldValue = func(context.Context) (*UserMetaData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMetaDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMetaDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMetaDataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMetaDataMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserMetaData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *UserMetaDataMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *UserMetaDataMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the UserMetaData entity.
// If the UserMetaData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMetaDataMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *UserMetaDataMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "Name" field.
func (m *UserMetaDataMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *UserMetaDataMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the UserMetaData entity.
// If the UserMetaData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMetaDataMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *UserMetaDataMutation) ResetName() {
	m._Name = nil
}

// SetValue sets the "Value" field.
func (m *UserMetaDataMutation) SetValue(s string) {
	m._Value = &s
}

// Value returns the value of the "Value" field in the mutation.
func (m *UserMetaDataMutation) Value() (r string, exists bool) {
	v := m._Value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "Value" field's value of the UserMetaData entity.
// If the UserMetaData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMetaDataMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "Value" field.
func (m *UserMetaDataMutation) ResetValue() {
	m._Value = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *UserMetaDataMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *UserMetaDataMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *UserMetaDataMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *UserMetaDataMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserMetaDataMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserMetaDataMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserMetaDataMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserMetaDataMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserMetaDataMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserMetaDataMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserMetaDataMutation builder.
func (m *UserMetaDataMutation) Where(ps ...predicate.UserMetaData) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMetaDataMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserMetaData).
func (m *UserMetaDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMetaDataMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tenant != nil {
		fields = append(fields, usermetadata.FieldTenantID)
	}
	if m._Name != nil {
		fields = append(fields, usermetadata.FieldName)
	}
	if m._Value != nil {
		fields = append(fields, usermetadata.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMetaDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usermetadata.FieldTenantID:
		return m.TenantID()
	case usermetadata.FieldName:
		return m.Name()
	case usermetadata.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMetaDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usermetadata.FieldTenantID:
		return m.OldTenantID(ctx)
	case usermetadata.FieldName:
		return m.OldName(ctx)
	case usermetadata.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown UserMetaData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMetaDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usermetadata.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case usermetadata.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case usermetadata.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown UserMetaData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMetaDataMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMetaDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMetaDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserMetaData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMetaDataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMetaDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMetaDataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserMetaData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMetaDataMutation) ResetField(name string) error {
	switch name {
	case usermetadata.FieldTenantID:
		m.ResetTenantID()
		return nil
	case usermetadata.FieldName:
		m.ResetName()
		return nil
	case usermetadata.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown UserMetaData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMetaDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, usermetadata.EdgeTenant)
	}
	if m.user != nil {
		edges = append(edges, usermetadata.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMetaDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usermetadata.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case usermetadata.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMetaDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMetaDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMetaDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, usermetadata.EdgeTenant)
	}
	if m.cleareduser {
		edges = append(edges, usermetadata.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMetaDataMutation) EdgeCleared(name string) bool {
	switch name {
	case usermetadata.EdgeTenant:
		return m.clearedtenant
	case usermetadata.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMetaDataMutation) ClearEdge(name string) error {
	switch name {
	case usermetadata.EdgeTenant:
		m.ClearTenant()
		return nil
	case usermetadata.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserMetaData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMetaDataMutation) ResetEdge(name string) error {
	switch name {
	case usermetadata.EdgeTenant:
		m.ResetTenant()
		return nil
	case usermetadata.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserMetaData edge %s", name)
}
