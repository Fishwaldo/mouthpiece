/*
	MIT License

	Copyright (c) 2021 Justin Hammond

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
*/

// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/Fishwaldo/mouthpiece/pkg/ent/dbapp"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/dbfilter"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/dbgroup"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/dbmessage"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/dbmessagefields"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/dbtransportinstances"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/dbtransportrecipients"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/dbuser"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/dbusermetadata"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/predicate"
	"github.com/Fishwaldo/mouthpiece/pkg/ent/tenant"
	"github.com/Fishwaldo/mouthpiece/pkg/interfaces"
	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDbApp                 = "DbApp"
	TypeDbFilter              = "DbFilter"
	TypeDbGroup               = "DbGroup"
	TypeDbMessage             = "DbMessage"
	TypeDbMessageFields       = "DbMessageFields"
	TypeDbTransportInstances  = "DbTransportInstances"
	TypeDbTransportRecipients = "DbTransportRecipients"
	TypeDbUser                = "DbUser"
	TypeDbUserMetaData        = "DbUserMetaData"
	TypeTenant                = "Tenant"
)

// DbAppMutation represents an operation that mutates the DbApp nodes in the graph.
type DbAppMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_Name           *string
	_Status         *interfaces.AppStatus
	_Description    *string
	icon            *string
	url             *string
	clearedFields   map[string]struct{}
	tenant          *int
	clearedtenant   bool
	messages        map[uuid.UUID]struct{}
	removedmessages map[uuid.UUID]struct{}
	clearedmessages bool
	filters         map[int]struct{}
	removedfilters  map[int]struct{}
	clearedfilters  bool
	groups          map[int]struct{}
	removedgroups   map[int]struct{}
	clearedgroups   bool
	done            bool
	oldValue        func(context.Context) (*DbApp, error)
	predicates      []predicate.DbApp
}

var _ ent.Mutation = (*DbAppMutation)(nil)

// dbappOption allows management of the mutation configuration using functional options.
type dbappOption func(*DbAppMutation)

// newDbAppMutation creates new mutation for the DbApp entity.
func newDbAppMutation(c config, op Op, opts ...dbappOption) *DbAppMutation {
	m := &DbAppMutation{
		config:        c,
		op:            op,
		typ:           TypeDbApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDbAppID sets the ID field of the mutation.
func withDbAppID(id int) dbappOption {
	return func(m *DbAppMutation) {
		var (
			err   error
			once  sync.Once
			value *DbApp
		)
		m.oldValue = func(ctx context.Context) (*DbApp, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DbApp.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDbApp sets the old DbApp of the mutation.
func withDbApp(node *DbApp) dbappOption {
	return func(m *DbAppMutation) {
		m.oldValue = func(context.Context) (*DbApp, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DbAppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DbAppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DbAppMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DbAppMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DbApp.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *DbAppMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DbAppMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DbApp entity.
// If the DbApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbAppMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DbAppMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "Name" field.
func (m *DbAppMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *DbAppMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the DbApp entity.
// If the DbApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbAppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *DbAppMutation) ResetName() {
	m._Name = nil
}

// SetStatus sets the "Status" field.
func (m *DbAppMutation) SetStatus(is interfaces.AppStatus) {
	m._Status = &is
}

// Status returns the value of the "Status" field in the mutation.
func (m *DbAppMutation) Status() (r interfaces.AppStatus, exists bool) {
	v := m._Status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "Status" field's value of the DbApp entity.
// If the DbApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbAppMutation) OldStatus(ctx context.Context) (v interfaces.AppStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "Status" field.
func (m *DbAppMutation) ResetStatus() {
	m._Status = nil
}

// SetDescription sets the "Description" field.
func (m *DbAppMutation) SetDescription(s string) {
	m._Description = &s
}

// Description returns the value of the "Description" field in the mutation.
func (m *DbAppMutation) Description() (r string, exists bool) {
	v := m._Description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "Description" field's value of the DbApp entity.
// If the DbApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbAppMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "Description" field.
func (m *DbAppMutation) ResetDescription() {
	m._Description = nil
}

// SetIcon sets the "icon" field.
func (m *DbAppMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *DbAppMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the DbApp entity.
// If the DbApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbAppMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *DbAppMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[dbapp.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *DbAppMutation) IconCleared() bool {
	_, ok := m.clearedFields[dbapp.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *DbAppMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, dbapp.FieldIcon)
}

// SetURL sets the "url" field.
func (m *DbAppMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *DbAppMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the DbApp entity.
// If the DbApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbAppMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *DbAppMutation) ClearURL() {
	m.url = nil
	m.clearedFields[dbapp.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *DbAppMutation) URLCleared() bool {
	_, ok := m.clearedFields[dbapp.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *DbAppMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, dbapp.FieldURL)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DbAppMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DbAppMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DbAppMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DbAppMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddMessageIDs adds the "messages" edge to the DbMessage entity by ids.
func (m *DbAppMutation) AddMessageIDs(ids ...uuid.UUID) {
	if m.messages == nil {
		m.messages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the DbMessage entity.
func (m *DbAppMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the DbMessage entity was cleared.
func (m *DbAppMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the DbMessage entity by IDs.
func (m *DbAppMutation) RemoveMessageIDs(ids ...uuid.UUID) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the DbMessage entity.
func (m *DbAppMutation) RemovedMessagesIDs() (ids []uuid.UUID) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *DbAppMutation) MessagesIDs() (ids []uuid.UUID) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *DbAppMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// AddFilterIDs adds the "filters" edge to the DbFilter entity by ids.
func (m *DbAppMutation) AddFilterIDs(ids ...int) {
	if m.filters == nil {
		m.filters = make(map[int]struct{})
	}
	for i := range ids {
		m.filters[ids[i]] = struct{}{}
	}
}

// ClearFilters clears the "filters" edge to the DbFilter entity.
func (m *DbAppMutation) ClearFilters() {
	m.clearedfilters = true
}

// FiltersCleared reports if the "filters" edge to the DbFilter entity was cleared.
func (m *DbAppMutation) FiltersCleared() bool {
	return m.clearedfilters
}

// RemoveFilterIDs removes the "filters" edge to the DbFilter entity by IDs.
func (m *DbAppMutation) RemoveFilterIDs(ids ...int) {
	if m.removedfilters == nil {
		m.removedfilters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.filters, ids[i])
		m.removedfilters[ids[i]] = struct{}{}
	}
}

// RemovedFilters returns the removed IDs of the "filters" edge to the DbFilter entity.
func (m *DbAppMutation) RemovedFiltersIDs() (ids []int) {
	for id := range m.removedfilters {
		ids = append(ids, id)
	}
	return
}

// FiltersIDs returns the "filters" edge IDs in the mutation.
func (m *DbAppMutation) FiltersIDs() (ids []int) {
	for id := range m.filters {
		ids = append(ids, id)
	}
	return
}

// ResetFilters resets all changes to the "filters" edge.
func (m *DbAppMutation) ResetFilters() {
	m.filters = nil
	m.clearedfilters = false
	m.removedfilters = nil
}

// AddGroupIDs adds the "groups" edge to the DbGroup entity by ids.
func (m *DbAppMutation) AddGroupIDs(ids ...int) {
	if m.groups == nil {
		m.groups = make(map[int]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the "groups" edge to the DbGroup entity.
func (m *DbAppMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared reports if the "groups" edge to the DbGroup entity was cleared.
func (m *DbAppMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the "groups" edge to the DbGroup entity by IDs.
func (m *DbAppMutation) RemoveGroupIDs(ids ...int) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.groups, ids[i])
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed IDs of the "groups" edge to the DbGroup entity.
func (m *DbAppMutation) RemovedGroupsIDs() (ids []int) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the "groups" edge IDs in the mutation.
func (m *DbAppMutation) GroupsIDs() (ids []int) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups resets all changes to the "groups" edge.
func (m *DbAppMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// Where appends a list predicates to the DbAppMutation builder.
func (m *DbAppMutation) Where(ps ...predicate.DbApp) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DbAppMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DbApp).
func (m *DbAppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DbAppMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.tenant != nil {
		fields = append(fields, dbapp.FieldTenantID)
	}
	if m._Name != nil {
		fields = append(fields, dbapp.FieldName)
	}
	if m._Status != nil {
		fields = append(fields, dbapp.FieldStatus)
	}
	if m._Description != nil {
		fields = append(fields, dbapp.FieldDescription)
	}
	if m.icon != nil {
		fields = append(fields, dbapp.FieldIcon)
	}
	if m.url != nil {
		fields = append(fields, dbapp.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DbAppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dbapp.FieldTenantID:
		return m.TenantID()
	case dbapp.FieldName:
		return m.Name()
	case dbapp.FieldStatus:
		return m.Status()
	case dbapp.FieldDescription:
		return m.Description()
	case dbapp.FieldIcon:
		return m.Icon()
	case dbapp.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DbAppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dbapp.FieldTenantID:
		return m.OldTenantID(ctx)
	case dbapp.FieldName:
		return m.OldName(ctx)
	case dbapp.FieldStatus:
		return m.OldStatus(ctx)
	case dbapp.FieldDescription:
		return m.OldDescription(ctx)
	case dbapp.FieldIcon:
		return m.OldIcon(ctx)
	case dbapp.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown DbApp field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DbAppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dbapp.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case dbapp.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dbapp.FieldStatus:
		v, ok := value.(interfaces.AppStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dbapp.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case dbapp.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case dbapp.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown DbApp field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DbAppMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DbAppMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DbAppMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DbApp numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DbAppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dbapp.FieldIcon) {
		fields = append(fields, dbapp.FieldIcon)
	}
	if m.FieldCleared(dbapp.FieldURL) {
		fields = append(fields, dbapp.FieldURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DbAppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DbAppMutation) ClearField(name string) error {
	switch name {
	case dbapp.FieldIcon:
		m.ClearIcon()
		return nil
	case dbapp.FieldURL:
		m.ClearURL()
		return nil
	}
	return fmt.Errorf("unknown DbApp nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DbAppMutation) ResetField(name string) error {
	switch name {
	case dbapp.FieldTenantID:
		m.ResetTenantID()
		return nil
	case dbapp.FieldName:
		m.ResetName()
		return nil
	case dbapp.FieldStatus:
		m.ResetStatus()
		return nil
	case dbapp.FieldDescription:
		m.ResetDescription()
		return nil
	case dbapp.FieldIcon:
		m.ResetIcon()
		return nil
	case dbapp.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown DbApp field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DbAppMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, dbapp.EdgeTenant)
	}
	if m.messages != nil {
		edges = append(edges, dbapp.EdgeMessages)
	}
	if m.filters != nil {
		edges = append(edges, dbapp.EdgeFilters)
	}
	if m.groups != nil {
		edges = append(edges, dbapp.EdgeGroups)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DbAppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dbapp.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case dbapp.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	case dbapp.EdgeFilters:
		ids := make([]ent.Value, 0, len(m.filters))
		for id := range m.filters {
			ids = append(ids, id)
		}
		return ids
	case dbapp.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DbAppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmessages != nil {
		edges = append(edges, dbapp.EdgeMessages)
	}
	if m.removedfilters != nil {
		edges = append(edges, dbapp.EdgeFilters)
	}
	if m.removedgroups != nil {
		edges = append(edges, dbapp.EdgeGroups)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DbAppMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dbapp.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	case dbapp.EdgeFilters:
		ids := make([]ent.Value, 0, len(m.removedfilters))
		for id := range m.removedfilters {
			ids = append(ids, id)
		}
		return ids
	case dbapp.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DbAppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, dbapp.EdgeTenant)
	}
	if m.clearedmessages {
		edges = append(edges, dbapp.EdgeMessages)
	}
	if m.clearedfilters {
		edges = append(edges, dbapp.EdgeFilters)
	}
	if m.clearedgroups {
		edges = append(edges, dbapp.EdgeGroups)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DbAppMutation) EdgeCleared(name string) bool {
	switch name {
	case dbapp.EdgeTenant:
		return m.clearedtenant
	case dbapp.EdgeMessages:
		return m.clearedmessages
	case dbapp.EdgeFilters:
		return m.clearedfilters
	case dbapp.EdgeGroups:
		return m.clearedgroups
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DbAppMutation) ClearEdge(name string) error {
	switch name {
	case dbapp.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown DbApp unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DbAppMutation) ResetEdge(name string) error {
	switch name {
	case dbapp.EdgeTenant:
		m.ResetTenant()
		return nil
	case dbapp.EdgeMessages:
		m.ResetMessages()
		return nil
	case dbapp.EdgeFilters:
		m.ResetFilters()
		return nil
	case dbapp.EdgeGroups:
		m.ResetGroups()
		return nil
	}
	return fmt.Errorf("unknown DbApp edge %s", name)
}

// DbFilterMutation represents an operation that mutates the DbFilter nodes in the graph.
type DbFilterMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Name         *string
	_Description  *string
	_Type         *interfaces.FilterType
	_Enabled      *bool
	_FilterImpl   *string
	_Config       *string
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	groups        map[int]struct{}
	removedgroups map[int]struct{}
	clearedgroups bool
	app           map[int]struct{}
	removedapp    map[int]struct{}
	clearedapp    bool
	user          map[int]struct{}
	removeduser   map[int]struct{}
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*DbFilter, error)
	predicates    []predicate.DbFilter
}

var _ ent.Mutation = (*DbFilterMutation)(nil)

// dbfilterOption allows management of the mutation configuration using functional options.
type dbfilterOption func(*DbFilterMutation)

// newDbFilterMutation creates new mutation for the DbFilter entity.
func newDbFilterMutation(c config, op Op, opts ...dbfilterOption) *DbFilterMutation {
	m := &DbFilterMutation{
		config:        c,
		op:            op,
		typ:           TypeDbFilter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDbFilterID sets the ID field of the mutation.
func withDbFilterID(id int) dbfilterOption {
	return func(m *DbFilterMutation) {
		var (
			err   error
			once  sync.Once
			value *DbFilter
		)
		m.oldValue = func(ctx context.Context) (*DbFilter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DbFilter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDbFilter sets the old DbFilter of the mutation.
func withDbFilter(node *DbFilter) dbfilterOption {
	return func(m *DbFilterMutation) {
		m.oldValue = func(context.Context) (*DbFilter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DbFilterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DbFilterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DbFilterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DbFilterMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DbFilter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *DbFilterMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DbFilterMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DbFilter entity.
// If the DbFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbFilterMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DbFilterMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "Name" field.
func (m *DbFilterMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *DbFilterMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the DbFilter entity.
// If the DbFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbFilterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *DbFilterMutation) ResetName() {
	m._Name = nil
}

// SetDescription sets the "Description" field.
func (m *DbFilterMutation) SetDescription(s string) {
	m._Description = &s
}

// Description returns the value of the "Description" field in the mutation.
func (m *DbFilterMutation) Description() (r string, exists bool) {
	v := m._Description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "Description" field's value of the DbFilter entity.
// If the DbFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbFilterMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "Description" field.
func (m *DbFilterMutation) ClearDescription() {
	m._Description = nil
	m.clearedFields[dbfilter.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "Description" field was cleared in this mutation.
func (m *DbFilterMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[dbfilter.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "Description" field.
func (m *DbFilterMutation) ResetDescription() {
	m._Description = nil
	delete(m.clearedFields, dbfilter.FieldDescription)
}

// SetType sets the "Type" field.
func (m *DbFilterMutation) SetType(it interfaces.FilterType) {
	m._Type = &it
}

// GetType returns the value of the "Type" field in the mutation.
func (m *DbFilterMutation) GetType() (r interfaces.FilterType, exists bool) {
	v := m._Type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "Type" field's value of the DbFilter entity.
// If the DbFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbFilterMutation) OldType(ctx context.Context) (v interfaces.FilterType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "Type" field.
func (m *DbFilterMutation) ResetType() {
	m._Type = nil
}

// SetEnabled sets the "Enabled" field.
func (m *DbFilterMutation) SetEnabled(b bool) {
	m._Enabled = &b
}

// Enabled returns the value of the "Enabled" field in the mutation.
func (m *DbFilterMutation) Enabled() (r bool, exists bool) {
	v := m._Enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "Enabled" field's value of the DbFilter entity.
// If the DbFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbFilterMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "Enabled" field.
func (m *DbFilterMutation) ResetEnabled() {
	m._Enabled = nil
}

// SetFilterImpl sets the "FilterImpl" field.
func (m *DbFilterMutation) SetFilterImpl(s string) {
	m._FilterImpl = &s
}

// FilterImpl returns the value of the "FilterImpl" field in the mutation.
func (m *DbFilterMutation) FilterImpl() (r string, exists bool) {
	v := m._FilterImpl
	if v == nil {
		return
	}
	return *v, true
}

// OldFilterImpl returns the old "FilterImpl" field's value of the DbFilter entity.
// If the DbFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbFilterMutation) OldFilterImpl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilterImpl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilterImpl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilterImpl: %w", err)
	}
	return oldValue.FilterImpl, nil
}

// ResetFilterImpl resets all changes to the "FilterImpl" field.
func (m *DbFilterMutation) ResetFilterImpl() {
	m._FilterImpl = nil
}

// SetConfig sets the "Config" field.
func (m *DbFilterMutation) SetConfig(s string) {
	m._Config = &s
}

// Config returns the value of the "Config" field in the mutation.
func (m *DbFilterMutation) Config() (r string, exists bool) {
	v := m._Config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "Config" field's value of the DbFilter entity.
// If the DbFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbFilterMutation) OldConfig(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "Config" field.
func (m *DbFilterMutation) ResetConfig() {
	m._Config = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DbFilterMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DbFilterMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DbFilterMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DbFilterMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddGroupIDs adds the "groups" edge to the DbGroup entity by ids.
func (m *DbFilterMutation) AddGroupIDs(ids ...int) {
	if m.groups == nil {
		m.groups = make(map[int]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the "groups" edge to the DbGroup entity.
func (m *DbFilterMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared reports if the "groups" edge to the DbGroup entity was cleared.
func (m *DbFilterMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the "groups" edge to the DbGroup entity by IDs.
func (m *DbFilterMutation) RemoveGroupIDs(ids ...int) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.groups, ids[i])
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed IDs of the "groups" edge to the DbGroup entity.
func (m *DbFilterMutation) RemovedGroupsIDs() (ids []int) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the "groups" edge IDs in the mutation.
func (m *DbFilterMutation) GroupsIDs() (ids []int) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups resets all changes to the "groups" edge.
func (m *DbFilterMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// AddAppIDs adds the "app" edge to the DbApp entity by ids.
func (m *DbFilterMutation) AddAppIDs(ids ...int) {
	if m.app == nil {
		m.app = make(map[int]struct{})
	}
	for i := range ids {
		m.app[ids[i]] = struct{}{}
	}
}

// ClearApp clears the "app" edge to the DbApp entity.
func (m *DbFilterMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the DbApp entity was cleared.
func (m *DbFilterMutation) AppCleared() bool {
	return m.clearedapp
}

// RemoveAppIDs removes the "app" edge to the DbApp entity by IDs.
func (m *DbFilterMutation) RemoveAppIDs(ids ...int) {
	if m.removedapp == nil {
		m.removedapp = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.app, ids[i])
		m.removedapp[ids[i]] = struct{}{}
	}
}

// RemovedApp returns the removed IDs of the "app" edge to the DbApp entity.
func (m *DbFilterMutation) RemovedAppIDs() (ids []int) {
	for id := range m.removedapp {
		ids = append(ids, id)
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
func (m *DbFilterMutation) AppIDs() (ids []int) {
	for id := range m.app {
		ids = append(ids, id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *DbFilterMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
	m.removedapp = nil
}

// AddUserIDs adds the "user" edge to the DbUser entity by ids.
func (m *DbFilterMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the DbUser entity.
func (m *DbFilterMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the DbUser entity was cleared.
func (m *DbFilterMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the DbUser entity by IDs.
func (m *DbFilterMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the DbUser entity.
func (m *DbFilterMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *DbFilterMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *DbFilterMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// Where appends a list predicates to the DbFilterMutation builder.
func (m *DbFilterMutation) Where(ps ...predicate.DbFilter) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DbFilterMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DbFilter).
func (m *DbFilterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DbFilterMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.tenant != nil {
		fields = append(fields, dbfilter.FieldTenantID)
	}
	if m._Name != nil {
		fields = append(fields, dbfilter.FieldName)
	}
	if m._Description != nil {
		fields = append(fields, dbfilter.FieldDescription)
	}
	if m._Type != nil {
		fields = append(fields, dbfilter.FieldType)
	}
	if m._Enabled != nil {
		fields = append(fields, dbfilter.FieldEnabled)
	}
	if m._FilterImpl != nil {
		fields = append(fields, dbfilter.FieldFilterImpl)
	}
	if m._Config != nil {
		fields = append(fields, dbfilter.FieldConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DbFilterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dbfilter.FieldTenantID:
		return m.TenantID()
	case dbfilter.FieldName:
		return m.Name()
	case dbfilter.FieldDescription:
		return m.Description()
	case dbfilter.FieldType:
		return m.GetType()
	case dbfilter.FieldEnabled:
		return m.Enabled()
	case dbfilter.FieldFilterImpl:
		return m.FilterImpl()
	case dbfilter.FieldConfig:
		return m.Config()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DbFilterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dbfilter.FieldTenantID:
		return m.OldTenantID(ctx)
	case dbfilter.FieldName:
		return m.OldName(ctx)
	case dbfilter.FieldDescription:
		return m.OldDescription(ctx)
	case dbfilter.FieldType:
		return m.OldType(ctx)
	case dbfilter.FieldEnabled:
		return m.OldEnabled(ctx)
	case dbfilter.FieldFilterImpl:
		return m.OldFilterImpl(ctx)
	case dbfilter.FieldConfig:
		return m.OldConfig(ctx)
	}
	return nil, fmt.Errorf("unknown DbFilter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DbFilterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dbfilter.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case dbfilter.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dbfilter.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case dbfilter.FieldType:
		v, ok := value.(interfaces.FilterType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case dbfilter.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case dbfilter.FieldFilterImpl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilterImpl(v)
		return nil
	case dbfilter.FieldConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	}
	return fmt.Errorf("unknown DbFilter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DbFilterMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DbFilterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DbFilterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DbFilter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DbFilterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dbfilter.FieldDescription) {
		fields = append(fields, dbfilter.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DbFilterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DbFilterMutation) ClearField(name string) error {
	switch name {
	case dbfilter.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown DbFilter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DbFilterMutation) ResetField(name string) error {
	switch name {
	case dbfilter.FieldTenantID:
		m.ResetTenantID()
		return nil
	case dbfilter.FieldName:
		m.ResetName()
		return nil
	case dbfilter.FieldDescription:
		m.ResetDescription()
		return nil
	case dbfilter.FieldType:
		m.ResetType()
		return nil
	case dbfilter.FieldEnabled:
		m.ResetEnabled()
		return nil
	case dbfilter.FieldFilterImpl:
		m.ResetFilterImpl()
		return nil
	case dbfilter.FieldConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown DbFilter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DbFilterMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, dbfilter.EdgeTenant)
	}
	if m.groups != nil {
		edges = append(edges, dbfilter.EdgeGroups)
	}
	if m.app != nil {
		edges = append(edges, dbfilter.EdgeApp)
	}
	if m.user != nil {
		edges = append(edges, dbfilter.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DbFilterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dbfilter.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case dbfilter.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	case dbfilter.EdgeApp:
		ids := make([]ent.Value, 0, len(m.app))
		for id := range m.app {
			ids = append(ids, id)
		}
		return ids
	case dbfilter.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DbFilterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedgroups != nil {
		edges = append(edges, dbfilter.EdgeGroups)
	}
	if m.removedapp != nil {
		edges = append(edges, dbfilter.EdgeApp)
	}
	if m.removeduser != nil {
		edges = append(edges, dbfilter.EdgeUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DbFilterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dbfilter.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	case dbfilter.EdgeApp:
		ids := make([]ent.Value, 0, len(m.removedapp))
		for id := range m.removedapp {
			ids = append(ids, id)
		}
		return ids
	case dbfilter.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DbFilterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, dbfilter.EdgeTenant)
	}
	if m.clearedgroups {
		edges = append(edges, dbfilter.EdgeGroups)
	}
	if m.clearedapp {
		edges = append(edges, dbfilter.EdgeApp)
	}
	if m.cleareduser {
		edges = append(edges, dbfilter.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DbFilterMutation) EdgeCleared(name string) bool {
	switch name {
	case dbfilter.EdgeTenant:
		return m.clearedtenant
	case dbfilter.EdgeGroups:
		return m.clearedgroups
	case dbfilter.EdgeApp:
		return m.clearedapp
	case dbfilter.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DbFilterMutation) ClearEdge(name string) error {
	switch name {
	case dbfilter.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown DbFilter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DbFilterMutation) ResetEdge(name string) error {
	switch name {
	case dbfilter.EdgeTenant:
		m.ResetTenant()
		return nil
	case dbfilter.EdgeGroups:
		m.ResetGroups()
		return nil
	case dbfilter.EdgeApp:
		m.ResetApp()
		return nil
	case dbfilter.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown DbFilter edge %s", name)
}

// DbGroupMutation represents an operation that mutates the DbGroup nodes in the graph.
type DbGroupMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	_Name                       *string
	_Description                *string
	clearedFields               map[string]struct{}
	tenant                      *int
	clearedtenant               bool
	_TransportRecipients        map[int]struct{}
	removed_TransportRecipients map[int]struct{}
	cleared_TransportRecipients bool
	users                       map[int]struct{}
	removedusers                map[int]struct{}
	clearedusers                bool
	filters                     map[int]struct{}
	removedfilters              map[int]struct{}
	clearedfilters              bool
	apps                        map[int]struct{}
	removedapps                 map[int]struct{}
	clearedapps                 bool
	done                        bool
	oldValue                    func(context.Context) (*DbGroup, error)
	predicates                  []predicate.DbGroup
}

var _ ent.Mutation = (*DbGroupMutation)(nil)

// dbgroupOption allows management of the mutation configuration using functional options.
type dbgroupOption func(*DbGroupMutation)

// newDbGroupMutation creates new mutation for the DbGroup entity.
func newDbGroupMutation(c config, op Op, opts ...dbgroupOption) *DbGroupMutation {
	m := &DbGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeDbGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDbGroupID sets the ID field of the mutation.
func withDbGroupID(id int) dbgroupOption {
	return func(m *DbGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *DbGroup
		)
		m.oldValue = func(ctx context.Context) (*DbGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DbGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDbGroup sets the old DbGroup of the mutation.
func withDbGroup(node *DbGroup) dbgroupOption {
	return func(m *DbGroupMutation) {
		m.oldValue = func(context.Context) (*DbGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DbGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DbGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DbGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DbGroupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DbGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *DbGroupMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DbGroupMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DbGroup entity.
// If the DbGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbGroupMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DbGroupMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "Name" field.
func (m *DbGroupMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *DbGroupMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the DbGroup entity.
// If the DbGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbGroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *DbGroupMutation) ResetName() {
	m._Name = nil
}

// SetDescription sets the "Description" field.
func (m *DbGroupMutation) SetDescription(s string) {
	m._Description = &s
}

// Description returns the value of the "Description" field in the mutation.
func (m *DbGroupMutation) Description() (r string, exists bool) {
	v := m._Description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "Description" field's value of the DbGroup entity.
// If the DbGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbGroupMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "Description" field.
func (m *DbGroupMutation) ClearDescription() {
	m._Description = nil
	m.clearedFields[dbgroup.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "Description" field was cleared in this mutation.
func (m *DbGroupMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[dbgroup.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "Description" field.
func (m *DbGroupMutation) ResetDescription() {
	m._Description = nil
	delete(m.clearedFields, dbgroup.FieldDescription)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DbGroupMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DbGroupMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DbGroupMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DbGroupMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddTransportRecipientIDs adds the "TransportRecipients" edge to the DbTransportRecipients entity by ids.
func (m *DbGroupMutation) AddTransportRecipientIDs(ids ...int) {
	if m._TransportRecipients == nil {
		m._TransportRecipients = make(map[int]struct{})
	}
	for i := range ids {
		m._TransportRecipients[ids[i]] = struct{}{}
	}
}

// ClearTransportRecipients clears the "TransportRecipients" edge to the DbTransportRecipients entity.
func (m *DbGroupMutation) ClearTransportRecipients() {
	m.cleared_TransportRecipients = true
}

// TransportRecipientsCleared reports if the "TransportRecipients" edge to the DbTransportRecipients entity was cleared.
func (m *DbGroupMutation) TransportRecipientsCleared() bool {
	return m.cleared_TransportRecipients
}

// RemoveTransportRecipientIDs removes the "TransportRecipients" edge to the DbTransportRecipients entity by IDs.
func (m *DbGroupMutation) RemoveTransportRecipientIDs(ids ...int) {
	if m.removed_TransportRecipients == nil {
		m.removed_TransportRecipients = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._TransportRecipients, ids[i])
		m.removed_TransportRecipients[ids[i]] = struct{}{}
	}
}

// RemovedTransportRecipients returns the removed IDs of the "TransportRecipients" edge to the DbTransportRecipients entity.
func (m *DbGroupMutation) RemovedTransportRecipientsIDs() (ids []int) {
	for id := range m.removed_TransportRecipients {
		ids = append(ids, id)
	}
	return
}

// TransportRecipientsIDs returns the "TransportRecipients" edge IDs in the mutation.
func (m *DbGroupMutation) TransportRecipientsIDs() (ids []int) {
	for id := range m._TransportRecipients {
		ids = append(ids, id)
	}
	return
}

// ResetTransportRecipients resets all changes to the "TransportRecipients" edge.
func (m *DbGroupMutation) ResetTransportRecipients() {
	m._TransportRecipients = nil
	m.cleared_TransportRecipients = false
	m.removed_TransportRecipients = nil
}

// AddUserIDs adds the "users" edge to the DbUser entity by ids.
func (m *DbGroupMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the DbUser entity.
func (m *DbGroupMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the DbUser entity was cleared.
func (m *DbGroupMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the DbUser entity by IDs.
func (m *DbGroupMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the DbUser entity.
func (m *DbGroupMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *DbGroupMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *DbGroupMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddFilterIDs adds the "filters" edge to the DbFilter entity by ids.
func (m *DbGroupMutation) AddFilterIDs(ids ...int) {
	if m.filters == nil {
		m.filters = make(map[int]struct{})
	}
	for i := range ids {
		m.filters[ids[i]] = struct{}{}
	}
}

// ClearFilters clears the "filters" edge to the DbFilter entity.
func (m *DbGroupMutation) ClearFilters() {
	m.clearedfilters = true
}

// FiltersCleared reports if the "filters" edge to the DbFilter entity was cleared.
func (m *DbGroupMutation) FiltersCleared() bool {
	return m.clearedfilters
}

// RemoveFilterIDs removes the "filters" edge to the DbFilter entity by IDs.
func (m *DbGroupMutation) RemoveFilterIDs(ids ...int) {
	if m.removedfilters == nil {
		m.removedfilters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.filters, ids[i])
		m.removedfilters[ids[i]] = struct{}{}
	}
}

// RemovedFilters returns the removed IDs of the "filters" edge to the DbFilter entity.
func (m *DbGroupMutation) RemovedFiltersIDs() (ids []int) {
	for id := range m.removedfilters {
		ids = append(ids, id)
	}
	return
}

// FiltersIDs returns the "filters" edge IDs in the mutation.
func (m *DbGroupMutation) FiltersIDs() (ids []int) {
	for id := range m.filters {
		ids = append(ids, id)
	}
	return
}

// ResetFilters resets all changes to the "filters" edge.
func (m *DbGroupMutation) ResetFilters() {
	m.filters = nil
	m.clearedfilters = false
	m.removedfilters = nil
}

// AddAppIDs adds the "apps" edge to the DbApp entity by ids.
func (m *DbGroupMutation) AddAppIDs(ids ...int) {
	if m.apps == nil {
		m.apps = make(map[int]struct{})
	}
	for i := range ids {
		m.apps[ids[i]] = struct{}{}
	}
}

// ClearApps clears the "apps" edge to the DbApp entity.
func (m *DbGroupMutation) ClearApps() {
	m.clearedapps = true
}

// AppsCleared reports if the "apps" edge to the DbApp entity was cleared.
func (m *DbGroupMutation) AppsCleared() bool {
	return m.clearedapps
}

// RemoveAppIDs removes the "apps" edge to the DbApp entity by IDs.
func (m *DbGroupMutation) RemoveAppIDs(ids ...int) {
	if m.removedapps == nil {
		m.removedapps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.apps, ids[i])
		m.removedapps[ids[i]] = struct{}{}
	}
}

// RemovedApps returns the removed IDs of the "apps" edge to the DbApp entity.
func (m *DbGroupMutation) RemovedAppsIDs() (ids []int) {
	for id := range m.removedapps {
		ids = append(ids, id)
	}
	return
}

// AppsIDs returns the "apps" edge IDs in the mutation.
func (m *DbGroupMutation) AppsIDs() (ids []int) {
	for id := range m.apps {
		ids = append(ids, id)
	}
	return
}

// ResetApps resets all changes to the "apps" edge.
func (m *DbGroupMutation) ResetApps() {
	m.apps = nil
	m.clearedapps = false
	m.removedapps = nil
}

// Where appends a list predicates to the DbGroupMutation builder.
func (m *DbGroupMutation) Where(ps ...predicate.DbGroup) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DbGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DbGroup).
func (m *DbGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DbGroupMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tenant != nil {
		fields = append(fields, dbgroup.FieldTenantID)
	}
	if m._Name != nil {
		fields = append(fields, dbgroup.FieldName)
	}
	if m._Description != nil {
		fields = append(fields, dbgroup.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DbGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dbgroup.FieldTenantID:
		return m.TenantID()
	case dbgroup.FieldName:
		return m.Name()
	case dbgroup.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DbGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dbgroup.FieldTenantID:
		return m.OldTenantID(ctx)
	case dbgroup.FieldName:
		return m.OldName(ctx)
	case dbgroup.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown DbGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DbGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dbgroup.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case dbgroup.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dbgroup.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown DbGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DbGroupMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DbGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DbGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DbGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DbGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dbgroup.FieldDescription) {
		fields = append(fields, dbgroup.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DbGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DbGroupMutation) ClearField(name string) error {
	switch name {
	case dbgroup.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown DbGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DbGroupMutation) ResetField(name string) error {
	switch name {
	case dbgroup.FieldTenantID:
		m.ResetTenantID()
		return nil
	case dbgroup.FieldName:
		m.ResetName()
		return nil
	case dbgroup.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown DbGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DbGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.tenant != nil {
		edges = append(edges, dbgroup.EdgeTenant)
	}
	if m._TransportRecipients != nil {
		edges = append(edges, dbgroup.EdgeTransportRecipients)
	}
	if m.users != nil {
		edges = append(edges, dbgroup.EdgeUsers)
	}
	if m.filters != nil {
		edges = append(edges, dbgroup.EdgeFilters)
	}
	if m.apps != nil {
		edges = append(edges, dbgroup.EdgeApps)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DbGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dbgroup.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case dbgroup.EdgeTransportRecipients:
		ids := make([]ent.Value, 0, len(m._TransportRecipients))
		for id := range m._TransportRecipients {
			ids = append(ids, id)
		}
		return ids
	case dbgroup.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case dbgroup.EdgeFilters:
		ids := make([]ent.Value, 0, len(m.filters))
		for id := range m.filters {
			ids = append(ids, id)
		}
		return ids
	case dbgroup.EdgeApps:
		ids := make([]ent.Value, 0, len(m.apps))
		for id := range m.apps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DbGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removed_TransportRecipients != nil {
		edges = append(edges, dbgroup.EdgeTransportRecipients)
	}
	if m.removedusers != nil {
		edges = append(edges, dbgroup.EdgeUsers)
	}
	if m.removedfilters != nil {
		edges = append(edges, dbgroup.EdgeFilters)
	}
	if m.removedapps != nil {
		edges = append(edges, dbgroup.EdgeApps)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DbGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dbgroup.EdgeTransportRecipients:
		ids := make([]ent.Value, 0, len(m.removed_TransportRecipients))
		for id := range m.removed_TransportRecipients {
			ids = append(ids, id)
		}
		return ids
	case dbgroup.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case dbgroup.EdgeFilters:
		ids := make([]ent.Value, 0, len(m.removedfilters))
		for id := range m.removedfilters {
			ids = append(ids, id)
		}
		return ids
	case dbgroup.EdgeApps:
		ids := make([]ent.Value, 0, len(m.removedapps))
		for id := range m.removedapps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DbGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtenant {
		edges = append(edges, dbgroup.EdgeTenant)
	}
	if m.cleared_TransportRecipients {
		edges = append(edges, dbgroup.EdgeTransportRecipients)
	}
	if m.clearedusers {
		edges = append(edges, dbgroup.EdgeUsers)
	}
	if m.clearedfilters {
		edges = append(edges, dbgroup.EdgeFilters)
	}
	if m.clearedapps {
		edges = append(edges, dbgroup.EdgeApps)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DbGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case dbgroup.EdgeTenant:
		return m.clearedtenant
	case dbgroup.EdgeTransportRecipients:
		return m.cleared_TransportRecipients
	case dbgroup.EdgeUsers:
		return m.clearedusers
	case dbgroup.EdgeFilters:
		return m.clearedfilters
	case dbgroup.EdgeApps:
		return m.clearedapps
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DbGroupMutation) ClearEdge(name string) error {
	switch name {
	case dbgroup.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown DbGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DbGroupMutation) ResetEdge(name string) error {
	switch name {
	case dbgroup.EdgeTenant:
		m.ResetTenant()
		return nil
	case dbgroup.EdgeTransportRecipients:
		m.ResetTransportRecipients()
		return nil
	case dbgroup.EdgeUsers:
		m.ResetUsers()
		return nil
	case dbgroup.EdgeFilters:
		m.ResetFilters()
		return nil
	case dbgroup.EdgeApps:
		m.ResetApps()
		return nil
	}
	return fmt.Errorf("unknown DbGroup edge %s", name)
}

// DbMessageMutation represents an operation that mutates the DbMessage nodes in the graph.
type DbMessageMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	_Message      *string
	_ShortMsg     *string
	_Topic        *string
	_Severity     *int
	add_Severity  *int
	_Timestamp    *time.Time
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	fields        map[int]struct{}
	removedfields map[int]struct{}
	clearedfields bool
	app           *int
	clearedapp    bool
	done          bool
	oldValue      func(context.Context) (*DbMessage, error)
	predicates    []predicate.DbMessage
}

var _ ent.Mutation = (*DbMessageMutation)(nil)

// dbmessageOption allows management of the mutation configuration using functional options.
type dbmessageOption func(*DbMessageMutation)

// newDbMessageMutation creates new mutation for the DbMessage entity.
func newDbMessageMutation(c config, op Op, opts ...dbmessageOption) *DbMessageMutation {
	m := &DbMessageMutation{
		config:        c,
		op:            op,
		typ:           TypeDbMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDbMessageID sets the ID field of the mutation.
func withDbMessageID(id uuid.UUID) dbmessageOption {
	return func(m *DbMessageMutation) {
		var (
			err   error
			once  sync.Once
			value *DbMessage
		)
		m.oldValue = func(ctx context.Context) (*DbMessage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DbMessage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDbMessage sets the old DbMessage of the mutation.
func withDbMessage(node *DbMessage) dbmessageOption {
	return func(m *DbMessageMutation) {
		m.oldValue = func(context.Context) (*DbMessage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DbMessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DbMessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DbMessage entities.
func (m *DbMessageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DbMessageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DbMessageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DbMessage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *DbMessageMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DbMessageMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DbMessage entity.
// If the DbMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbMessageMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DbMessageMutation) ResetTenantID() {
	m.tenant = nil
}

// SetMessage sets the "Message" field.
func (m *DbMessageMutation) SetMessage(s string) {
	m._Message = &s
}

// Message returns the value of the "Message" field in the mutation.
func (m *DbMessageMutation) Message() (r string, exists bool) {
	v := m._Message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "Message" field's value of the DbMessage entity.
// If the DbMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbMessageMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "Message" field.
func (m *DbMessageMutation) ResetMessage() {
	m._Message = nil
}

// SetShortMsg sets the "ShortMsg" field.
func (m *DbMessageMutation) SetShortMsg(s string) {
	m._ShortMsg = &s
}

// ShortMsg returns the value of the "ShortMsg" field in the mutation.
func (m *DbMessageMutation) ShortMsg() (r string, exists bool) {
	v := m._ShortMsg
	if v == nil {
		return
	}
	return *v, true
}

// OldShortMsg returns the old "ShortMsg" field's value of the DbMessage entity.
// If the DbMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbMessageMutation) OldShortMsg(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShortMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShortMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShortMsg: %w", err)
	}
	return oldValue.ShortMsg, nil
}

// ClearShortMsg clears the value of the "ShortMsg" field.
func (m *DbMessageMutation) ClearShortMsg() {
	m._ShortMsg = nil
	m.clearedFields[dbmessage.FieldShortMsg] = struct{}{}
}

// ShortMsgCleared returns if the "ShortMsg" field was cleared in this mutation.
func (m *DbMessageMutation) ShortMsgCleared() bool {
	_, ok := m.clearedFields[dbmessage.FieldShortMsg]
	return ok
}

// ResetShortMsg resets all changes to the "ShortMsg" field.
func (m *DbMessageMutation) ResetShortMsg() {
	m._ShortMsg = nil
	delete(m.clearedFields, dbmessage.FieldShortMsg)
}

// SetTopic sets the "Topic" field.
func (m *DbMessageMutation) SetTopic(s string) {
	m._Topic = &s
}

// Topic returns the value of the "Topic" field in the mutation.
func (m *DbMessageMutation) Topic() (r string, exists bool) {
	v := m._Topic
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic returns the old "Topic" field's value of the DbMessage entity.
// If the DbMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbMessageMutation) OldTopic(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic: %w", err)
	}
	return oldValue.Topic, nil
}

// ClearTopic clears the value of the "Topic" field.
func (m *DbMessageMutation) ClearTopic() {
	m._Topic = nil
	m.clearedFields[dbmessage.FieldTopic] = struct{}{}
}

// TopicCleared returns if the "Topic" field was cleared in this mutation.
func (m *DbMessageMutation) TopicCleared() bool {
	_, ok := m.clearedFields[dbmessage.FieldTopic]
	return ok
}

// ResetTopic resets all changes to the "Topic" field.
func (m *DbMessageMutation) ResetTopic() {
	m._Topic = nil
	delete(m.clearedFields, dbmessage.FieldTopic)
}

// SetSeverity sets the "Severity" field.
func (m *DbMessageMutation) SetSeverity(i int) {
	m._Severity = &i
	m.add_Severity = nil
}

// Severity returns the value of the "Severity" field in the mutation.
func (m *DbMessageMutation) Severity() (r int, exists bool) {
	v := m._Severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "Severity" field's value of the DbMessage entity.
// If the DbMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbMessageMutation) OldSeverity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// AddSeverity adds i to the "Severity" field.
func (m *DbMessageMutation) AddSeverity(i int) {
	if m.add_Severity != nil {
		*m.add_Severity += i
	} else {
		m.add_Severity = &i
	}
}

// AddedSeverity returns the value that was added to the "Severity" field in this mutation.
func (m *DbMessageMutation) AddedSeverity() (r int, exists bool) {
	v := m.add_Severity
	if v == nil {
		return
	}
	return *v, true
}

// ClearSeverity clears the value of the "Severity" field.
func (m *DbMessageMutation) ClearSeverity() {
	m._Severity = nil
	m.add_Severity = nil
	m.clearedFields[dbmessage.FieldSeverity] = struct{}{}
}

// SeverityCleared returns if the "Severity" field was cleared in this mutation.
func (m *DbMessageMutation) SeverityCleared() bool {
	_, ok := m.clearedFields[dbmessage.FieldSeverity]
	return ok
}

// ResetSeverity resets all changes to the "Severity" field.
func (m *DbMessageMutation) ResetSeverity() {
	m._Severity = nil
	m.add_Severity = nil
	delete(m.clearedFields, dbmessage.FieldSeverity)
}

// SetTimestamp sets the "Timestamp" field.
func (m *DbMessageMutation) SetTimestamp(t time.Time) {
	m._Timestamp = &t
}

// Timestamp returns the value of the "Timestamp" field in the mutation.
func (m *DbMessageMutation) Timestamp() (r time.Time, exists bool) {
	v := m._Timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "Timestamp" field's value of the DbMessage entity.
// If the DbMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbMessageMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "Timestamp" field.
func (m *DbMessageMutation) ResetTimestamp() {
	m._Timestamp = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DbMessageMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DbMessageMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DbMessageMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DbMessageMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddFieldIDs adds the "fields" edge to the DbMessageFields entity by ids.
func (m *DbMessageMutation) AddFieldIDs(ids ...int) {
	if m.fields == nil {
		m.fields = make(map[int]struct{})
	}
	for i := range ids {
		m.fields[ids[i]] = struct{}{}
	}
}

// ClearFields clears the "fields" edge to the DbMessageFields entity.
func (m *DbMessageMutation) ClearFields() {
	m.clearedfields = true
}

// FieldsCleared reports if the "fields" edge to the DbMessageFields entity was cleared.
func (m *DbMessageMutation) FieldsCleared() bool {
	return m.clearedfields
}

// RemoveFieldIDs removes the "fields" edge to the DbMessageFields entity by IDs.
func (m *DbMessageMutation) RemoveFieldIDs(ids ...int) {
	if m.removedfields == nil {
		m.removedfields = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.fields, ids[i])
		m.removedfields[ids[i]] = struct{}{}
	}
}

// RemovedFields returns the removed IDs of the "fields" edge to the DbMessageFields entity.
func (m *DbMessageMutation) RemovedFieldsIDs() (ids []int) {
	for id := range m.removedfields {
		ids = append(ids, id)
	}
	return
}

// FieldsIDs returns the "fields" edge IDs in the mutation.
func (m *DbMessageMutation) FieldsIDs() (ids []int) {
	for id := range m.fields {
		ids = append(ids, id)
	}
	return
}

// ResetFields resets all changes to the "fields" edge.
func (m *DbMessageMutation) ResetFields() {
	m.fields = nil
	m.clearedfields = false
	m.removedfields = nil
}

// SetAppID sets the "app" edge to the DbApp entity by id.
func (m *DbMessageMutation) SetAppID(id int) {
	m.app = &id
}

// ClearApp clears the "app" edge to the DbApp entity.
func (m *DbMessageMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the DbApp entity was cleared.
func (m *DbMessageMutation) AppCleared() bool {
	return m.clearedapp
}

// AppID returns the "app" edge ID in the mutation.
func (m *DbMessageMutation) AppID() (id int, exists bool) {
	if m.app != nil {
		return *m.app, true
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *DbMessageMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *DbMessageMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// Where appends a list predicates to the DbMessageMutation builder.
func (m *DbMessageMutation) Where(ps ...predicate.DbMessage) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DbMessageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DbMessage).
func (m *DbMessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DbMessageMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.tenant != nil {
		fields = append(fields, dbmessage.FieldTenantID)
	}
	if m._Message != nil {
		fields = append(fields, dbmessage.FieldMessage)
	}
	if m._ShortMsg != nil {
		fields = append(fields, dbmessage.FieldShortMsg)
	}
	if m._Topic != nil {
		fields = append(fields, dbmessage.FieldTopic)
	}
	if m._Severity != nil {
		fields = append(fields, dbmessage.FieldSeverity)
	}
	if m._Timestamp != nil {
		fields = append(fields, dbmessage.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DbMessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dbmessage.FieldTenantID:
		return m.TenantID()
	case dbmessage.FieldMessage:
		return m.Message()
	case dbmessage.FieldShortMsg:
		return m.ShortMsg()
	case dbmessage.FieldTopic:
		return m.Topic()
	case dbmessage.FieldSeverity:
		return m.Severity()
	case dbmessage.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DbMessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dbmessage.FieldTenantID:
		return m.OldTenantID(ctx)
	case dbmessage.FieldMessage:
		return m.OldMessage(ctx)
	case dbmessage.FieldShortMsg:
		return m.OldShortMsg(ctx)
	case dbmessage.FieldTopic:
		return m.OldTopic(ctx)
	case dbmessage.FieldSeverity:
		return m.OldSeverity(ctx)
	case dbmessage.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown DbMessage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DbMessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dbmessage.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case dbmessage.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case dbmessage.FieldShortMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShortMsg(v)
		return nil
	case dbmessage.FieldTopic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic(v)
		return nil
	case dbmessage.FieldSeverity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case dbmessage.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown DbMessage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DbMessageMutation) AddedFields() []string {
	var fields []string
	if m.add_Severity != nil {
		fields = append(fields, dbmessage.FieldSeverity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DbMessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dbmessage.FieldSeverity:
		return m.AddedSeverity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DbMessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dbmessage.FieldSeverity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeverity(v)
		return nil
	}
	return fmt.Errorf("unknown DbMessage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DbMessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dbmessage.FieldShortMsg) {
		fields = append(fields, dbmessage.FieldShortMsg)
	}
	if m.FieldCleared(dbmessage.FieldTopic) {
		fields = append(fields, dbmessage.FieldTopic)
	}
	if m.FieldCleared(dbmessage.FieldSeverity) {
		fields = append(fields, dbmessage.FieldSeverity)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DbMessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DbMessageMutation) ClearField(name string) error {
	switch name {
	case dbmessage.FieldShortMsg:
		m.ClearShortMsg()
		return nil
	case dbmessage.FieldTopic:
		m.ClearTopic()
		return nil
	case dbmessage.FieldSeverity:
		m.ClearSeverity()
		return nil
	}
	return fmt.Errorf("unknown DbMessage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DbMessageMutation) ResetField(name string) error {
	switch name {
	case dbmessage.FieldTenantID:
		m.ResetTenantID()
		return nil
	case dbmessage.FieldMessage:
		m.ResetMessage()
		return nil
	case dbmessage.FieldShortMsg:
		m.ResetShortMsg()
		return nil
	case dbmessage.FieldTopic:
		m.ResetTopic()
		return nil
	case dbmessage.FieldSeverity:
		m.ResetSeverity()
		return nil
	case dbmessage.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown DbMessage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DbMessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, dbmessage.EdgeTenant)
	}
	if m.fields != nil {
		edges = append(edges, dbmessage.EdgeFields)
	}
	if m.app != nil {
		edges = append(edges, dbmessage.EdgeApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DbMessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dbmessage.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case dbmessage.EdgeFields:
		ids := make([]ent.Value, 0, len(m.fields))
		for id := range m.fields {
			ids = append(ids, id)
		}
		return ids
	case dbmessage.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DbMessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedfields != nil {
		edges = append(edges, dbmessage.EdgeFields)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DbMessageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dbmessage.EdgeFields:
		ids := make([]ent.Value, 0, len(m.removedfields))
		for id := range m.removedfields {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DbMessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, dbmessage.EdgeTenant)
	}
	if m.clearedfields {
		edges = append(edges, dbmessage.EdgeFields)
	}
	if m.clearedapp {
		edges = append(edges, dbmessage.EdgeApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DbMessageMutation) EdgeCleared(name string) bool {
	switch name {
	case dbmessage.EdgeTenant:
		return m.clearedtenant
	case dbmessage.EdgeFields:
		return m.clearedfields
	case dbmessage.EdgeApp:
		return m.clearedapp
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DbMessageMutation) ClearEdge(name string) error {
	switch name {
	case dbmessage.EdgeTenant:
		m.ClearTenant()
		return nil
	case dbmessage.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown DbMessage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DbMessageMutation) ResetEdge(name string) error {
	switch name {
	case dbmessage.EdgeTenant:
		m.ResetTenant()
		return nil
	case dbmessage.EdgeFields:
		m.ResetFields()
		return nil
	case dbmessage.EdgeApp:
		m.ResetApp()
		return nil
	}
	return fmt.Errorf("unknown DbMessage edge %s", name)
}

// DbMessageFieldsMutation represents an operation that mutates the DbMessageFields nodes in the graph.
type DbMessageFieldsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Name         *string
	_Value        *string
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	owner         *uuid.UUID
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*DbMessageFields, error)
	predicates    []predicate.DbMessageFields
}

var _ ent.Mutation = (*DbMessageFieldsMutation)(nil)

// dbmessagefieldsOption allows management of the mutation configuration using functional options.
type dbmessagefieldsOption func(*DbMessageFieldsMutation)

// newDbMessageFieldsMutation creates new mutation for the DbMessageFields entity.
func newDbMessageFieldsMutation(c config, op Op, opts ...dbmessagefieldsOption) *DbMessageFieldsMutation {
	m := &DbMessageFieldsMutation{
		config:        c,
		op:            op,
		typ:           TypeDbMessageFields,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDbMessageFieldsID sets the ID field of the mutation.
func withDbMessageFieldsID(id int) dbmessagefieldsOption {
	return func(m *DbMessageFieldsMutation) {
		var (
			err   error
			once  sync.Once
			value *DbMessageFields
		)
		m.oldValue = func(ctx context.Context) (*DbMessageFields, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DbMessageFields.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDbMessageFields sets the old DbMessageFields of the mutation.
func withDbMessageFields(node *DbMessageFields) dbmessagefieldsOption {
	return func(m *DbMessageFieldsMutation) {
		m.oldValue = func(context.Context) (*DbMessageFields, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DbMessageFieldsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DbMessageFieldsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DbMessageFieldsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DbMessageFieldsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DbMessageFields.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *DbMessageFieldsMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DbMessageFieldsMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DbMessageFields entity.
// If the DbMessageFields object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbMessageFieldsMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DbMessageFieldsMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "Name" field.
func (m *DbMessageFieldsMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *DbMessageFieldsMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the DbMessageFields entity.
// If the DbMessageFields object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbMessageFieldsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *DbMessageFieldsMutation) ResetName() {
	m._Name = nil
}

// SetValue sets the "Value" field.
func (m *DbMessageFieldsMutation) SetValue(s string) {
	m._Value = &s
}

// Value returns the value of the "Value" field in the mutation.
func (m *DbMessageFieldsMutation) Value() (r string, exists bool) {
	v := m._Value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "Value" field's value of the DbMessageFields entity.
// If the DbMessageFields object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbMessageFieldsMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "Value" field.
func (m *DbMessageFieldsMutation) ResetValue() {
	m._Value = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DbMessageFieldsMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DbMessageFieldsMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DbMessageFieldsMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DbMessageFieldsMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetOwnerID sets the "owner" edge to the DbMessage entity by id.
func (m *DbMessageFieldsMutation) SetOwnerID(id uuid.UUID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the DbMessage entity.
func (m *DbMessageFieldsMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the DbMessage entity was cleared.
func (m *DbMessageFieldsMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *DbMessageFieldsMutation) OwnerID() (id uuid.UUID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *DbMessageFieldsMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *DbMessageFieldsMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the DbMessageFieldsMutation builder.
func (m *DbMessageFieldsMutation) Where(ps ...predicate.DbMessageFields) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DbMessageFieldsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DbMessageFields).
func (m *DbMessageFieldsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DbMessageFieldsMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tenant != nil {
		fields = append(fields, dbmessagefields.FieldTenantID)
	}
	if m._Name != nil {
		fields = append(fields, dbmessagefields.FieldName)
	}
	if m._Value != nil {
		fields = append(fields, dbmessagefields.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DbMessageFieldsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dbmessagefields.FieldTenantID:
		return m.TenantID()
	case dbmessagefields.FieldName:
		return m.Name()
	case dbmessagefields.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DbMessageFieldsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dbmessagefields.FieldTenantID:
		return m.OldTenantID(ctx)
	case dbmessagefields.FieldName:
		return m.OldName(ctx)
	case dbmessagefields.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown DbMessageFields field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DbMessageFieldsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dbmessagefields.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case dbmessagefields.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dbmessagefields.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown DbMessageFields field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DbMessageFieldsMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DbMessageFieldsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DbMessageFieldsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DbMessageFields numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DbMessageFieldsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DbMessageFieldsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DbMessageFieldsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DbMessageFields nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DbMessageFieldsMutation) ResetField(name string) error {
	switch name {
	case dbmessagefields.FieldTenantID:
		m.ResetTenantID()
		return nil
	case dbmessagefields.FieldName:
		m.ResetName()
		return nil
	case dbmessagefields.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown DbMessageFields field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DbMessageFieldsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, dbmessagefields.EdgeTenant)
	}
	if m.owner != nil {
		edges = append(edges, dbmessagefields.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DbMessageFieldsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dbmessagefields.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case dbmessagefields.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DbMessageFieldsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DbMessageFieldsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DbMessageFieldsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, dbmessagefields.EdgeTenant)
	}
	if m.clearedowner {
		edges = append(edges, dbmessagefields.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DbMessageFieldsMutation) EdgeCleared(name string) bool {
	switch name {
	case dbmessagefields.EdgeTenant:
		return m.clearedtenant
	case dbmessagefields.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DbMessageFieldsMutation) ClearEdge(name string) error {
	switch name {
	case dbmessagefields.EdgeTenant:
		m.ClearTenant()
		return nil
	case dbmessagefields.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown DbMessageFields unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DbMessageFieldsMutation) ResetEdge(name string) error {
	switch name {
	case dbmessagefields.EdgeTenant:
		m.ResetTenant()
		return nil
	case dbmessagefields.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown DbMessageFields edge %s", name)
}

// DbTransportInstancesMutation represents an operation that mutates the DbTransportInstances nodes in the graph.
type DbTransportInstancesMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	_Name                       *string
	_Description                *string
	_Config                     *string
	_TransportProvider          *string
	clearedFields               map[string]struct{}
	tenant                      *int
	clearedtenant               bool
	_TransportRecipients        map[int]struct{}
	removed_TransportRecipients map[int]struct{}
	cleared_TransportRecipients bool
	done                        bool
	oldValue                    func(context.Context) (*DbTransportInstances, error)
	predicates                  []predicate.DbTransportInstances
}

var _ ent.Mutation = (*DbTransportInstancesMutation)(nil)

// dbtransportinstancesOption allows management of the mutation configuration using functional options.
type dbtransportinstancesOption func(*DbTransportInstancesMutation)

// newDbTransportInstancesMutation creates new mutation for the DbTransportInstances entity.
func newDbTransportInstancesMutation(c config, op Op, opts ...dbtransportinstancesOption) *DbTransportInstancesMutation {
	m := &DbTransportInstancesMutation{
		config:        c,
		op:            op,
		typ:           TypeDbTransportInstances,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDbTransportInstancesID sets the ID field of the mutation.
func withDbTransportInstancesID(id int) dbtransportinstancesOption {
	return func(m *DbTransportInstancesMutation) {
		var (
			err   error
			once  sync.Once
			value *DbTransportInstances
		)
		m.oldValue = func(ctx context.Context) (*DbTransportInstances, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DbTransportInstances.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDbTransportInstances sets the old DbTransportInstances of the mutation.
func withDbTransportInstances(node *DbTransportInstances) dbtransportinstancesOption {
	return func(m *DbTransportInstancesMutation) {
		m.oldValue = func(context.Context) (*DbTransportInstances, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DbTransportInstancesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DbTransportInstancesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DbTransportInstancesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DbTransportInstancesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DbTransportInstances.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *DbTransportInstancesMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DbTransportInstancesMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DbTransportInstances entity.
// If the DbTransportInstances object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbTransportInstancesMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DbTransportInstancesMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "Name" field.
func (m *DbTransportInstancesMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *DbTransportInstancesMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the DbTransportInstances entity.
// If the DbTransportInstances object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbTransportInstancesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *DbTransportInstancesMutation) ResetName() {
	m._Name = nil
}

// SetDescription sets the "Description" field.
func (m *DbTransportInstancesMutation) SetDescription(s string) {
	m._Description = &s
}

// Description returns the value of the "Description" field in the mutation.
func (m *DbTransportInstancesMutation) Description() (r string, exists bool) {
	v := m._Description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "Description" field's value of the DbTransportInstances entity.
// If the DbTransportInstances object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbTransportInstancesMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "Description" field.
func (m *DbTransportInstancesMutation) ClearDescription() {
	m._Description = nil
	m.clearedFields[dbtransportinstances.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "Description" field was cleared in this mutation.
func (m *DbTransportInstancesMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[dbtransportinstances.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "Description" field.
func (m *DbTransportInstancesMutation) ResetDescription() {
	m._Description = nil
	delete(m.clearedFields, dbtransportinstances.FieldDescription)
}

// SetConfig sets the "Config" field.
func (m *DbTransportInstancesMutation) SetConfig(s string) {
	m._Config = &s
}

// Config returns the value of the "Config" field in the mutation.
func (m *DbTransportInstancesMutation) Config() (r string, exists bool) {
	v := m._Config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "Config" field's value of the DbTransportInstances entity.
// If the DbTransportInstances object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbTransportInstancesMutation) OldConfig(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "Config" field.
func (m *DbTransportInstancesMutation) ResetConfig() {
	m._Config = nil
}

// SetTransportProvider sets the "TransportProvider" field.
func (m *DbTransportInstancesMutation) SetTransportProvider(s string) {
	m._TransportProvider = &s
}

// TransportProvider returns the value of the "TransportProvider" field in the mutation.
func (m *DbTransportInstancesMutation) TransportProvider() (r string, exists bool) {
	v := m._TransportProvider
	if v == nil {
		return
	}
	return *v, true
}

// OldTransportProvider returns the old "TransportProvider" field's value of the DbTransportInstances entity.
// If the DbTransportInstances object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbTransportInstancesMutation) OldTransportProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransportProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransportProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransportProvider: %w", err)
	}
	return oldValue.TransportProvider, nil
}

// ResetTransportProvider resets all changes to the "TransportProvider" field.
func (m *DbTransportInstancesMutation) ResetTransportProvider() {
	m._TransportProvider = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DbTransportInstancesMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DbTransportInstancesMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DbTransportInstancesMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DbTransportInstancesMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddTransportRecipientIDs adds the "TransportRecipients" edge to the DbTransportRecipients entity by ids.
func (m *DbTransportInstancesMutation) AddTransportRecipientIDs(ids ...int) {
	if m._TransportRecipients == nil {
		m._TransportRecipients = make(map[int]struct{})
	}
	for i := range ids {
		m._TransportRecipients[ids[i]] = struct{}{}
	}
}

// ClearTransportRecipients clears the "TransportRecipients" edge to the DbTransportRecipients entity.
func (m *DbTransportInstancesMutation) ClearTransportRecipients() {
	m.cleared_TransportRecipients = true
}

// TransportRecipientsCleared reports if the "TransportRecipients" edge to the DbTransportRecipients entity was cleared.
func (m *DbTransportInstancesMutation) TransportRecipientsCleared() bool {
	return m.cleared_TransportRecipients
}

// RemoveTransportRecipientIDs removes the "TransportRecipients" edge to the DbTransportRecipients entity by IDs.
func (m *DbTransportInstancesMutation) RemoveTransportRecipientIDs(ids ...int) {
	if m.removed_TransportRecipients == nil {
		m.removed_TransportRecipients = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._TransportRecipients, ids[i])
		m.removed_TransportRecipients[ids[i]] = struct{}{}
	}
}

// RemovedTransportRecipients returns the removed IDs of the "TransportRecipients" edge to the DbTransportRecipients entity.
func (m *DbTransportInstancesMutation) RemovedTransportRecipientsIDs() (ids []int) {
	for id := range m.removed_TransportRecipients {
		ids = append(ids, id)
	}
	return
}

// TransportRecipientsIDs returns the "TransportRecipients" edge IDs in the mutation.
func (m *DbTransportInstancesMutation) TransportRecipientsIDs() (ids []int) {
	for id := range m._TransportRecipients {
		ids = append(ids, id)
	}
	return
}

// ResetTransportRecipients resets all changes to the "TransportRecipients" edge.
func (m *DbTransportInstancesMutation) ResetTransportRecipients() {
	m._TransportRecipients = nil
	m.cleared_TransportRecipients = false
	m.removed_TransportRecipients = nil
}

// Where appends a list predicates to the DbTransportInstancesMutation builder.
func (m *DbTransportInstancesMutation) Where(ps ...predicate.DbTransportInstances) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DbTransportInstancesMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DbTransportInstances).
func (m *DbTransportInstancesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DbTransportInstancesMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.tenant != nil {
		fields = append(fields, dbtransportinstances.FieldTenantID)
	}
	if m._Name != nil {
		fields = append(fields, dbtransportinstances.FieldName)
	}
	if m._Description != nil {
		fields = append(fields, dbtransportinstances.FieldDescription)
	}
	if m._Config != nil {
		fields = append(fields, dbtransportinstances.FieldConfig)
	}
	if m._TransportProvider != nil {
		fields = append(fields, dbtransportinstances.FieldTransportProvider)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DbTransportInstancesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dbtransportinstances.FieldTenantID:
		return m.TenantID()
	case dbtransportinstances.FieldName:
		return m.Name()
	case dbtransportinstances.FieldDescription:
		return m.Description()
	case dbtransportinstances.FieldConfig:
		return m.Config()
	case dbtransportinstances.FieldTransportProvider:
		return m.TransportProvider()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DbTransportInstancesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dbtransportinstances.FieldTenantID:
		return m.OldTenantID(ctx)
	case dbtransportinstances.FieldName:
		return m.OldName(ctx)
	case dbtransportinstances.FieldDescription:
		return m.OldDescription(ctx)
	case dbtransportinstances.FieldConfig:
		return m.OldConfig(ctx)
	case dbtransportinstances.FieldTransportProvider:
		return m.OldTransportProvider(ctx)
	}
	return nil, fmt.Errorf("unknown DbTransportInstances field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DbTransportInstancesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dbtransportinstances.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case dbtransportinstances.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dbtransportinstances.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case dbtransportinstances.FieldConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case dbtransportinstances.FieldTransportProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransportProvider(v)
		return nil
	}
	return fmt.Errorf("unknown DbTransportInstances field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DbTransportInstancesMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DbTransportInstancesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DbTransportInstancesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DbTransportInstances numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DbTransportInstancesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dbtransportinstances.FieldDescription) {
		fields = append(fields, dbtransportinstances.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DbTransportInstancesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DbTransportInstancesMutation) ClearField(name string) error {
	switch name {
	case dbtransportinstances.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown DbTransportInstances nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DbTransportInstancesMutation) ResetField(name string) error {
	switch name {
	case dbtransportinstances.FieldTenantID:
		m.ResetTenantID()
		return nil
	case dbtransportinstances.FieldName:
		m.ResetName()
		return nil
	case dbtransportinstances.FieldDescription:
		m.ResetDescription()
		return nil
	case dbtransportinstances.FieldConfig:
		m.ResetConfig()
		return nil
	case dbtransportinstances.FieldTransportProvider:
		m.ResetTransportProvider()
		return nil
	}
	return fmt.Errorf("unknown DbTransportInstances field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DbTransportInstancesMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, dbtransportinstances.EdgeTenant)
	}
	if m._TransportRecipients != nil {
		edges = append(edges, dbtransportinstances.EdgeTransportRecipients)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DbTransportInstancesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dbtransportinstances.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case dbtransportinstances.EdgeTransportRecipients:
		ids := make([]ent.Value, 0, len(m._TransportRecipients))
		for id := range m._TransportRecipients {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DbTransportInstancesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_TransportRecipients != nil {
		edges = append(edges, dbtransportinstances.EdgeTransportRecipients)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DbTransportInstancesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dbtransportinstances.EdgeTransportRecipients:
		ids := make([]ent.Value, 0, len(m.removed_TransportRecipients))
		for id := range m.removed_TransportRecipients {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DbTransportInstancesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, dbtransportinstances.EdgeTenant)
	}
	if m.cleared_TransportRecipients {
		edges = append(edges, dbtransportinstances.EdgeTransportRecipients)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DbTransportInstancesMutation) EdgeCleared(name string) bool {
	switch name {
	case dbtransportinstances.EdgeTenant:
		return m.clearedtenant
	case dbtransportinstances.EdgeTransportRecipients:
		return m.cleared_TransportRecipients
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DbTransportInstancesMutation) ClearEdge(name string) error {
	switch name {
	case dbtransportinstances.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown DbTransportInstances unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DbTransportInstancesMutation) ResetEdge(name string) error {
	switch name {
	case dbtransportinstances.EdgeTenant:
		m.ResetTenant()
		return nil
	case dbtransportinstances.EdgeTransportRecipients:
		m.ResetTransportRecipients()
		return nil
	}
	return fmt.Errorf("unknown DbTransportInstances edge %s", name)
}

// DbTransportRecipientsMutation represents an operation that mutates the DbTransportRecipients nodes in the graph.
type DbTransportRecipientsMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	_Name                     *string
	_Description              *string
	_config                   *string
	clearedFields             map[string]struct{}
	tenant                    *int
	clearedtenant             bool
	_TransportInstance        *int
	cleared_TransportInstance bool
	_GroupRecipient           *int
	cleared_GroupRecipient    bool
	_UserRecipient            *int
	cleared_UserRecipient     bool
	done                      bool
	oldValue                  func(context.Context) (*DbTransportRecipients, error)
	predicates                []predicate.DbTransportRecipients
}

var _ ent.Mutation = (*DbTransportRecipientsMutation)(nil)

// dbtransportrecipientsOption allows management of the mutation configuration using functional options.
type dbtransportrecipientsOption func(*DbTransportRecipientsMutation)

// newDbTransportRecipientsMutation creates new mutation for the DbTransportRecipients entity.
func newDbTransportRecipientsMutation(c config, op Op, opts ...dbtransportrecipientsOption) *DbTransportRecipientsMutation {
	m := &DbTransportRecipientsMutation{
		config:        c,
		op:            op,
		typ:           TypeDbTransportRecipients,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDbTransportRecipientsID sets the ID field of the mutation.
func withDbTransportRecipientsID(id int) dbtransportrecipientsOption {
	return func(m *DbTransportRecipientsMutation) {
		var (
			err   error
			once  sync.Once
			value *DbTransportRecipients
		)
		m.oldValue = func(ctx context.Context) (*DbTransportRecipients, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DbTransportRecipients.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDbTransportRecipients sets the old DbTransportRecipients of the mutation.
func withDbTransportRecipients(node *DbTransportRecipients) dbtransportrecipientsOption {
	return func(m *DbTransportRecipientsMutation) {
		m.oldValue = func(context.Context) (*DbTransportRecipients, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DbTransportRecipientsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DbTransportRecipientsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DbTransportRecipientsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DbTransportRecipientsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DbTransportRecipients.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *DbTransportRecipientsMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DbTransportRecipientsMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DbTransportRecipients entity.
// If the DbTransportRecipients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbTransportRecipientsMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DbTransportRecipientsMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "Name" field.
func (m *DbTransportRecipientsMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *DbTransportRecipientsMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the DbTransportRecipients entity.
// If the DbTransportRecipients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbTransportRecipientsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *DbTransportRecipientsMutation) ResetName() {
	m._Name = nil
}

// SetDescription sets the "Description" field.
func (m *DbTransportRecipientsMutation) SetDescription(s string) {
	m._Description = &s
}

// Description returns the value of the "Description" field in the mutation.
func (m *DbTransportRecipientsMutation) Description() (r string, exists bool) {
	v := m._Description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "Description" field's value of the DbTransportRecipients entity.
// If the DbTransportRecipients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbTransportRecipientsMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "Description" field.
func (m *DbTransportRecipientsMutation) ClearDescription() {
	m._Description = nil
	m.clearedFields[dbtransportrecipients.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "Description" field was cleared in this mutation.
func (m *DbTransportRecipientsMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[dbtransportrecipients.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "Description" field.
func (m *DbTransportRecipientsMutation) ResetDescription() {
	m._Description = nil
	delete(m.clearedFields, dbtransportrecipients.FieldDescription)
}

// SetConfig sets the "config" field.
func (m *DbTransportRecipientsMutation) SetConfig(s string) {
	m._config = &s
}

// Config returns the value of the "config" field in the mutation.
func (m *DbTransportRecipientsMutation) Config() (r string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the DbTransportRecipients entity.
// If the DbTransportRecipients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbTransportRecipientsMutation) OldConfig(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *DbTransportRecipientsMutation) ResetConfig() {
	m._config = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DbTransportRecipientsMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DbTransportRecipientsMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DbTransportRecipientsMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DbTransportRecipientsMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetTransportInstanceID sets the "TransportInstance" edge to the DbTransportInstances entity by id.
func (m *DbTransportRecipientsMutation) SetTransportInstanceID(id int) {
	m._TransportInstance = &id
}

// ClearTransportInstance clears the "TransportInstance" edge to the DbTransportInstances entity.
func (m *DbTransportRecipientsMutation) ClearTransportInstance() {
	m.cleared_TransportInstance = true
}

// TransportInstanceCleared reports if the "TransportInstance" edge to the DbTransportInstances entity was cleared.
func (m *DbTransportRecipientsMutation) TransportInstanceCleared() bool {
	return m.cleared_TransportInstance
}

// TransportInstanceID returns the "TransportInstance" edge ID in the mutation.
func (m *DbTransportRecipientsMutation) TransportInstanceID() (id int, exists bool) {
	if m._TransportInstance != nil {
		return *m._TransportInstance, true
	}
	return
}

// TransportInstanceIDs returns the "TransportInstance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransportInstanceID instead. It exists only for internal usage by the builders.
func (m *DbTransportRecipientsMutation) TransportInstanceIDs() (ids []int) {
	if id := m._TransportInstance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransportInstance resets all changes to the "TransportInstance" edge.
func (m *DbTransportRecipientsMutation) ResetTransportInstance() {
	m._TransportInstance = nil
	m.cleared_TransportInstance = false
}

// SetGroupRecipientID sets the "GroupRecipient" edge to the DbGroup entity by id.
func (m *DbTransportRecipientsMutation) SetGroupRecipientID(id int) {
	m._GroupRecipient = &id
}

// ClearGroupRecipient clears the "GroupRecipient" edge to the DbGroup entity.
func (m *DbTransportRecipientsMutation) ClearGroupRecipient() {
	m.cleared_GroupRecipient = true
}

// GroupRecipientCleared reports if the "GroupRecipient" edge to the DbGroup entity was cleared.
func (m *DbTransportRecipientsMutation) GroupRecipientCleared() bool {
	return m.cleared_GroupRecipient
}

// GroupRecipientID returns the "GroupRecipient" edge ID in the mutation.
func (m *DbTransportRecipientsMutation) GroupRecipientID() (id int, exists bool) {
	if m._GroupRecipient != nil {
		return *m._GroupRecipient, true
	}
	return
}

// GroupRecipientIDs returns the "GroupRecipient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupRecipientID instead. It exists only for internal usage by the builders.
func (m *DbTransportRecipientsMutation) GroupRecipientIDs() (ids []int) {
	if id := m._GroupRecipient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroupRecipient resets all changes to the "GroupRecipient" edge.
func (m *DbTransportRecipientsMutation) ResetGroupRecipient() {
	m._GroupRecipient = nil
	m.cleared_GroupRecipient = false
}

// SetUserRecipientID sets the "UserRecipient" edge to the DbUser entity by id.
func (m *DbTransportRecipientsMutation) SetUserRecipientID(id int) {
	m._UserRecipient = &id
}

// ClearUserRecipient clears the "UserRecipient" edge to the DbUser entity.
func (m *DbTransportRecipientsMutation) ClearUserRecipient() {
	m.cleared_UserRecipient = true
}

// UserRecipientCleared reports if the "UserRecipient" edge to the DbUser entity was cleared.
func (m *DbTransportRecipientsMutation) UserRecipientCleared() bool {
	return m.cleared_UserRecipient
}

// UserRecipientID returns the "UserRecipient" edge ID in the mutation.
func (m *DbTransportRecipientsMutation) UserRecipientID() (id int, exists bool) {
	if m._UserRecipient != nil {
		return *m._UserRecipient, true
	}
	return
}

// UserRecipientIDs returns the "UserRecipient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserRecipientID instead. It exists only for internal usage by the builders.
func (m *DbTransportRecipientsMutation) UserRecipientIDs() (ids []int) {
	if id := m._UserRecipient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserRecipient resets all changes to the "UserRecipient" edge.
func (m *DbTransportRecipientsMutation) ResetUserRecipient() {
	m._UserRecipient = nil
	m.cleared_UserRecipient = false
}

// Where appends a list predicates to the DbTransportRecipientsMutation builder.
func (m *DbTransportRecipientsMutation) Where(ps ...predicate.DbTransportRecipients) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DbTransportRecipientsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DbTransportRecipients).
func (m *DbTransportRecipientsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DbTransportRecipientsMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.tenant != nil {
		fields = append(fields, dbtransportrecipients.FieldTenantID)
	}
	if m._Name != nil {
		fields = append(fields, dbtransportrecipients.FieldName)
	}
	if m._Description != nil {
		fields = append(fields, dbtransportrecipients.FieldDescription)
	}
	if m._config != nil {
		fields = append(fields, dbtransportrecipients.FieldConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DbTransportRecipientsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dbtransportrecipients.FieldTenantID:
		return m.TenantID()
	case dbtransportrecipients.FieldName:
		return m.Name()
	case dbtransportrecipients.FieldDescription:
		return m.Description()
	case dbtransportrecipients.FieldConfig:
		return m.Config()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DbTransportRecipientsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dbtransportrecipients.FieldTenantID:
		return m.OldTenantID(ctx)
	case dbtransportrecipients.FieldName:
		return m.OldName(ctx)
	case dbtransportrecipients.FieldDescription:
		return m.OldDescription(ctx)
	case dbtransportrecipients.FieldConfig:
		return m.OldConfig(ctx)
	}
	return nil, fmt.Errorf("unknown DbTransportRecipients field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DbTransportRecipientsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dbtransportrecipients.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case dbtransportrecipients.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dbtransportrecipients.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case dbtransportrecipients.FieldConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	}
	return fmt.Errorf("unknown DbTransportRecipients field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DbTransportRecipientsMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DbTransportRecipientsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DbTransportRecipientsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DbTransportRecipients numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DbTransportRecipientsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dbtransportrecipients.FieldDescription) {
		fields = append(fields, dbtransportrecipients.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DbTransportRecipientsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DbTransportRecipientsMutation) ClearField(name string) error {
	switch name {
	case dbtransportrecipients.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown DbTransportRecipients nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DbTransportRecipientsMutation) ResetField(name string) error {
	switch name {
	case dbtransportrecipients.FieldTenantID:
		m.ResetTenantID()
		return nil
	case dbtransportrecipients.FieldName:
		m.ResetName()
		return nil
	case dbtransportrecipients.FieldDescription:
		m.ResetDescription()
		return nil
	case dbtransportrecipients.FieldConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown DbTransportRecipients field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DbTransportRecipientsMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, dbtransportrecipients.EdgeTenant)
	}
	if m._TransportInstance != nil {
		edges = append(edges, dbtransportrecipients.EdgeTransportInstance)
	}
	if m._GroupRecipient != nil {
		edges = append(edges, dbtransportrecipients.EdgeGroupRecipient)
	}
	if m._UserRecipient != nil {
		edges = append(edges, dbtransportrecipients.EdgeUserRecipient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DbTransportRecipientsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dbtransportrecipients.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case dbtransportrecipients.EdgeTransportInstance:
		if id := m._TransportInstance; id != nil {
			return []ent.Value{*id}
		}
	case dbtransportrecipients.EdgeGroupRecipient:
		if id := m._GroupRecipient; id != nil {
			return []ent.Value{*id}
		}
	case dbtransportrecipients.EdgeUserRecipient:
		if id := m._UserRecipient; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DbTransportRecipientsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DbTransportRecipientsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DbTransportRecipientsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, dbtransportrecipients.EdgeTenant)
	}
	if m.cleared_TransportInstance {
		edges = append(edges, dbtransportrecipients.EdgeTransportInstance)
	}
	if m.cleared_GroupRecipient {
		edges = append(edges, dbtransportrecipients.EdgeGroupRecipient)
	}
	if m.cleared_UserRecipient {
		edges = append(edges, dbtransportrecipients.EdgeUserRecipient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DbTransportRecipientsMutation) EdgeCleared(name string) bool {
	switch name {
	case dbtransportrecipients.EdgeTenant:
		return m.clearedtenant
	case dbtransportrecipients.EdgeTransportInstance:
		return m.cleared_TransportInstance
	case dbtransportrecipients.EdgeGroupRecipient:
		return m.cleared_GroupRecipient
	case dbtransportrecipients.EdgeUserRecipient:
		return m.cleared_UserRecipient
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DbTransportRecipientsMutation) ClearEdge(name string) error {
	switch name {
	case dbtransportrecipients.EdgeTenant:
		m.ClearTenant()
		return nil
	case dbtransportrecipients.EdgeTransportInstance:
		m.ClearTransportInstance()
		return nil
	case dbtransportrecipients.EdgeGroupRecipient:
		m.ClearGroupRecipient()
		return nil
	case dbtransportrecipients.EdgeUserRecipient:
		m.ClearUserRecipient()
		return nil
	}
	return fmt.Errorf("unknown DbTransportRecipients unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DbTransportRecipientsMutation) ResetEdge(name string) error {
	switch name {
	case dbtransportrecipients.EdgeTenant:
		m.ResetTenant()
		return nil
	case dbtransportrecipients.EdgeTransportInstance:
		m.ResetTransportInstance()
		return nil
	case dbtransportrecipients.EdgeGroupRecipient:
		m.ResetGroupRecipient()
		return nil
	case dbtransportrecipients.EdgeUserRecipient:
		m.ResetUserRecipient()
		return nil
	}
	return fmt.Errorf("unknown DbTransportRecipients edge %s", name)
}

// DbUserMutation represents an operation that mutates the DbUser nodes in the graph.
type DbUserMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	_Email                      *string
	_Name                       *string
	_Description                *string
	clearedFields               map[string]struct{}
	tenant                      *int
	clearedtenant               bool
	metadata                    map[int]struct{}
	removedmetadata             map[int]struct{}
	clearedmetadata             bool
	filters                     map[int]struct{}
	removedfilters              map[int]struct{}
	clearedfilters              bool
	groups                      map[int]struct{}
	removedgroups               map[int]struct{}
	clearedgroups               bool
	_TransportRecipients        map[int]struct{}
	removed_TransportRecipients map[int]struct{}
	cleared_TransportRecipients bool
	done                        bool
	oldValue                    func(context.Context) (*DbUser, error)
	predicates                  []predicate.DbUser
}

var _ ent.Mutation = (*DbUserMutation)(nil)

// dbuserOption allows management of the mutation configuration using functional options.
type dbuserOption func(*DbUserMutation)

// newDbUserMutation creates new mutation for the DbUser entity.
func newDbUserMutation(c config, op Op, opts ...dbuserOption) *DbUserMutation {
	m := &DbUserMutation{
		config:        c,
		op:            op,
		typ:           TypeDbUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDbUserID sets the ID field of the mutation.
func withDbUserID(id int) dbuserOption {
	return func(m *DbUserMutation) {
		var (
			err   error
			once  sync.Once
			value *DbUser
		)
		m.oldValue = func(ctx context.Context) (*DbUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DbUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDbUser sets the old DbUser of the mutation.
func withDbUser(node *DbUser) dbuserOption {
	return func(m *DbUserMutation) {
		m.oldValue = func(context.Context) (*DbUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DbUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DbUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DbUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DbUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DbUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *DbUserMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DbUserMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DbUser entity.
// If the DbUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbUserMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DbUserMutation) ResetTenantID() {
	m.tenant = nil
}

// SetEmail sets the "Email" field.
func (m *DbUserMutation) SetEmail(s string) {
	m._Email = &s
}

// Email returns the value of the "Email" field in the mutation.
func (m *DbUserMutation) Email() (r string, exists bool) {
	v := m._Email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "Email" field's value of the DbUser entity.
// If the DbUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbUserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "Email" field.
func (m *DbUserMutation) ResetEmail() {
	m._Email = nil
}

// SetName sets the "Name" field.
func (m *DbUserMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *DbUserMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the DbUser entity.
// If the DbUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbUserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *DbUserMutation) ResetName() {
	m._Name = nil
}

// SetDescription sets the "Description" field.
func (m *DbUserMutation) SetDescription(s string) {
	m._Description = &s
}

// Description returns the value of the "Description" field in the mutation.
func (m *DbUserMutation) Description() (r string, exists bool) {
	v := m._Description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "Description" field's value of the DbUser entity.
// If the DbUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbUserMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "Description" field.
func (m *DbUserMutation) ClearDescription() {
	m._Description = nil
	m.clearedFields[dbuser.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "Description" field was cleared in this mutation.
func (m *DbUserMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[dbuser.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "Description" field.
func (m *DbUserMutation) ResetDescription() {
	m._Description = nil
	delete(m.clearedFields, dbuser.FieldDescription)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DbUserMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DbUserMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DbUserMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DbUserMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddMetadatumIDs adds the "metadata" edge to the DbUserMetaData entity by ids.
func (m *DbUserMutation) AddMetadatumIDs(ids ...int) {
	if m.metadata == nil {
		m.metadata = make(map[int]struct{})
	}
	for i := range ids {
		m.metadata[ids[i]] = struct{}{}
	}
}

// ClearMetadata clears the "metadata" edge to the DbUserMetaData entity.
func (m *DbUserMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the DbUserMetaData entity was cleared.
func (m *DbUserMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// RemoveMetadatumIDs removes the "metadata" edge to the DbUserMetaData entity by IDs.
func (m *DbUserMutation) RemoveMetadatumIDs(ids ...int) {
	if m.removedmetadata == nil {
		m.removedmetadata = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.metadata, ids[i])
		m.removedmetadata[ids[i]] = struct{}{}
	}
}

// RemovedMetadata returns the removed IDs of the "metadata" edge to the DbUserMetaData entity.
func (m *DbUserMutation) RemovedMetadataIDs() (ids []int) {
	for id := range m.removedmetadata {
		ids = append(ids, id)
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
func (m *DbUserMutation) MetadataIDs() (ids []int) {
	for id := range m.metadata {
		ids = append(ids, id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *DbUserMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
	m.removedmetadata = nil
}

// AddFilterIDs adds the "filters" edge to the DbFilter entity by ids.
func (m *DbUserMutation) AddFilterIDs(ids ...int) {
	if m.filters == nil {
		m.filters = make(map[int]struct{})
	}
	for i := range ids {
		m.filters[ids[i]] = struct{}{}
	}
}

// ClearFilters clears the "filters" edge to the DbFilter entity.
func (m *DbUserMutation) ClearFilters() {
	m.clearedfilters = true
}

// FiltersCleared reports if the "filters" edge to the DbFilter entity was cleared.
func (m *DbUserMutation) FiltersCleared() bool {
	return m.clearedfilters
}

// RemoveFilterIDs removes the "filters" edge to the DbFilter entity by IDs.
func (m *DbUserMutation) RemoveFilterIDs(ids ...int) {
	if m.removedfilters == nil {
		m.removedfilters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.filters, ids[i])
		m.removedfilters[ids[i]] = struct{}{}
	}
}

// RemovedFilters returns the removed IDs of the "filters" edge to the DbFilter entity.
func (m *DbUserMutation) RemovedFiltersIDs() (ids []int) {
	for id := range m.removedfilters {
		ids = append(ids, id)
	}
	return
}

// FiltersIDs returns the "filters" edge IDs in the mutation.
func (m *DbUserMutation) FiltersIDs() (ids []int) {
	for id := range m.filters {
		ids = append(ids, id)
	}
	return
}

// ResetFilters resets all changes to the "filters" edge.
func (m *DbUserMutation) ResetFilters() {
	m.filters = nil
	m.clearedfilters = false
	m.removedfilters = nil
}

// AddGroupIDs adds the "groups" edge to the DbGroup entity by ids.
func (m *DbUserMutation) AddGroupIDs(ids ...int) {
	if m.groups == nil {
		m.groups = make(map[int]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the "groups" edge to the DbGroup entity.
func (m *DbUserMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared reports if the "groups" edge to the DbGroup entity was cleared.
func (m *DbUserMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the "groups" edge to the DbGroup entity by IDs.
func (m *DbUserMutation) RemoveGroupIDs(ids ...int) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.groups, ids[i])
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed IDs of the "groups" edge to the DbGroup entity.
func (m *DbUserMutation) RemovedGroupsIDs() (ids []int) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the "groups" edge IDs in the mutation.
func (m *DbUserMutation) GroupsIDs() (ids []int) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups resets all changes to the "groups" edge.
func (m *DbUserMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// AddTransportRecipientIDs adds the "TransportRecipients" edge to the DbTransportRecipients entity by ids.
func (m *DbUserMutation) AddTransportRecipientIDs(ids ...int) {
	if m._TransportRecipients == nil {
		m._TransportRecipients = make(map[int]struct{})
	}
	for i := range ids {
		m._TransportRecipients[ids[i]] = struct{}{}
	}
}

// ClearTransportRecipients clears the "TransportRecipients" edge to the DbTransportRecipients entity.
func (m *DbUserMutation) ClearTransportRecipients() {
	m.cleared_TransportRecipients = true
}

// TransportRecipientsCleared reports if the "TransportRecipients" edge to the DbTransportRecipients entity was cleared.
func (m *DbUserMutation) TransportRecipientsCleared() bool {
	return m.cleared_TransportRecipients
}

// RemoveTransportRecipientIDs removes the "TransportRecipients" edge to the DbTransportRecipients entity by IDs.
func (m *DbUserMutation) RemoveTransportRecipientIDs(ids ...int) {
	if m.removed_TransportRecipients == nil {
		m.removed_TransportRecipients = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._TransportRecipients, ids[i])
		m.removed_TransportRecipients[ids[i]] = struct{}{}
	}
}

// RemovedTransportRecipients returns the removed IDs of the "TransportRecipients" edge to the DbTransportRecipients entity.
func (m *DbUserMutation) RemovedTransportRecipientsIDs() (ids []int) {
	for id := range m.removed_TransportRecipients {
		ids = append(ids, id)
	}
	return
}

// TransportRecipientsIDs returns the "TransportRecipients" edge IDs in the mutation.
func (m *DbUserMutation) TransportRecipientsIDs() (ids []int) {
	for id := range m._TransportRecipients {
		ids = append(ids, id)
	}
	return
}

// ResetTransportRecipients resets all changes to the "TransportRecipients" edge.
func (m *DbUserMutation) ResetTransportRecipients() {
	m._TransportRecipients = nil
	m.cleared_TransportRecipients = false
	m.removed_TransportRecipients = nil
}

// Where appends a list predicates to the DbUserMutation builder.
func (m *DbUserMutation) Where(ps ...predicate.DbUser) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DbUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DbUser).
func (m *DbUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DbUserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.tenant != nil {
		fields = append(fields, dbuser.FieldTenantID)
	}
	if m._Email != nil {
		fields = append(fields, dbuser.FieldEmail)
	}
	if m._Name != nil {
		fields = append(fields, dbuser.FieldName)
	}
	if m._Description != nil {
		fields = append(fields, dbuser.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DbUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dbuser.FieldTenantID:
		return m.TenantID()
	case dbuser.FieldEmail:
		return m.Email()
	case dbuser.FieldName:
		return m.Name()
	case dbuser.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DbUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dbuser.FieldTenantID:
		return m.OldTenantID(ctx)
	case dbuser.FieldEmail:
		return m.OldEmail(ctx)
	case dbuser.FieldName:
		return m.OldName(ctx)
	case dbuser.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown DbUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DbUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dbuser.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case dbuser.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case dbuser.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dbuser.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown DbUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DbUserMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DbUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DbUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DbUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DbUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dbuser.FieldDescription) {
		fields = append(fields, dbuser.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DbUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DbUserMutation) ClearField(name string) error {
	switch name {
	case dbuser.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown DbUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DbUserMutation) ResetField(name string) error {
	switch name {
	case dbuser.FieldTenantID:
		m.ResetTenantID()
		return nil
	case dbuser.FieldEmail:
		m.ResetEmail()
		return nil
	case dbuser.FieldName:
		m.ResetName()
		return nil
	case dbuser.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown DbUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DbUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.tenant != nil {
		edges = append(edges, dbuser.EdgeTenant)
	}
	if m.metadata != nil {
		edges = append(edges, dbuser.EdgeMetadata)
	}
	if m.filters != nil {
		edges = append(edges, dbuser.EdgeFilters)
	}
	if m.groups != nil {
		edges = append(edges, dbuser.EdgeGroups)
	}
	if m._TransportRecipients != nil {
		edges = append(edges, dbuser.EdgeTransportRecipients)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DbUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dbuser.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case dbuser.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.metadata))
		for id := range m.metadata {
			ids = append(ids, id)
		}
		return ids
	case dbuser.EdgeFilters:
		ids := make([]ent.Value, 0, len(m.filters))
		for id := range m.filters {
			ids = append(ids, id)
		}
		return ids
	case dbuser.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	case dbuser.EdgeTransportRecipients:
		ids := make([]ent.Value, 0, len(m._TransportRecipients))
		for id := range m._TransportRecipients {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DbUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedmetadata != nil {
		edges = append(edges, dbuser.EdgeMetadata)
	}
	if m.removedfilters != nil {
		edges = append(edges, dbuser.EdgeFilters)
	}
	if m.removedgroups != nil {
		edges = append(edges, dbuser.EdgeGroups)
	}
	if m.removed_TransportRecipients != nil {
		edges = append(edges, dbuser.EdgeTransportRecipients)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DbUserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dbuser.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.removedmetadata))
		for id := range m.removedmetadata {
			ids = append(ids, id)
		}
		return ids
	case dbuser.EdgeFilters:
		ids := make([]ent.Value, 0, len(m.removedfilters))
		for id := range m.removedfilters {
			ids = append(ids, id)
		}
		return ids
	case dbuser.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	case dbuser.EdgeTransportRecipients:
		ids := make([]ent.Value, 0, len(m.removed_TransportRecipients))
		for id := range m.removed_TransportRecipients {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DbUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtenant {
		edges = append(edges, dbuser.EdgeTenant)
	}
	if m.clearedmetadata {
		edges = append(edges, dbuser.EdgeMetadata)
	}
	if m.clearedfilters {
		edges = append(edges, dbuser.EdgeFilters)
	}
	if m.clearedgroups {
		edges = append(edges, dbuser.EdgeGroups)
	}
	if m.cleared_TransportRecipients {
		edges = append(edges, dbuser.EdgeTransportRecipients)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DbUserMutation) EdgeCleared(name string) bool {
	switch name {
	case dbuser.EdgeTenant:
		return m.clearedtenant
	case dbuser.EdgeMetadata:
		return m.clearedmetadata
	case dbuser.EdgeFilters:
		return m.clearedfilters
	case dbuser.EdgeGroups:
		return m.clearedgroups
	case dbuser.EdgeTransportRecipients:
		return m.cleared_TransportRecipients
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DbUserMutation) ClearEdge(name string) error {
	switch name {
	case dbuser.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown DbUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DbUserMutation) ResetEdge(name string) error {
	switch name {
	case dbuser.EdgeTenant:
		m.ResetTenant()
		return nil
	case dbuser.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case dbuser.EdgeFilters:
		m.ResetFilters()
		return nil
	case dbuser.EdgeGroups:
		m.ResetGroups()
		return nil
	case dbuser.EdgeTransportRecipients:
		m.ResetTransportRecipients()
		return nil
	}
	return fmt.Errorf("unknown DbUser edge %s", name)
}

// DbUserMetaDataMutation represents an operation that mutates the DbUserMetaData nodes in the graph.
type DbUserMetaDataMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Name         *string
	_Value        *string
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*DbUserMetaData, error)
	predicates    []predicate.DbUserMetaData
}

var _ ent.Mutation = (*DbUserMetaDataMutation)(nil)

// dbusermetadataOption allows management of the mutation configuration using functional options.
type dbusermetadataOption func(*DbUserMetaDataMutation)

// newDbUserMetaDataMutation creates new mutation for the DbUserMetaData entity.
func newDbUserMetaDataMutation(c config, op Op, opts ...dbusermetadataOption) *DbUserMetaDataMutation {
	m := &DbUserMetaDataMutation{
		config:        c,
		op:            op,
		typ:           TypeDbUserMetaData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDbUserMetaDataID sets the ID field of the mutation.
func withDbUserMetaDataID(id int) dbusermetadataOption {
	return func(m *DbUserMetaDataMutation) {
		var (
			err   error
			once  sync.Once
			value *DbUserMetaData
		)
		m.oldValue = func(ctx context.Context) (*DbUserMetaData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DbUserMetaData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDbUserMetaData sets the old DbUserMetaData of the mutation.
func withDbUserMetaData(node *DbUserMetaData) dbusermetadataOption {
	return func(m *DbUserMetaDataMutation) {
		m.oldValue = func(context.Context) (*DbUserMetaData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DbUserMetaDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DbUserMetaDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DbUserMetaDataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DbUserMetaDataMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DbUserMetaData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *DbUserMetaDataMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DbUserMetaDataMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DbUserMetaData entity.
// If the DbUserMetaData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbUserMetaDataMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DbUserMetaDataMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "Name" field.
func (m *DbUserMetaDataMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *DbUserMetaDataMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the DbUserMetaData entity.
// If the DbUserMetaData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbUserMetaDataMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *DbUserMetaDataMutation) ResetName() {
	m._Name = nil
}

// SetValue sets the "Value" field.
func (m *DbUserMetaDataMutation) SetValue(s string) {
	m._Value = &s
}

// Value returns the value of the "Value" field in the mutation.
func (m *DbUserMetaDataMutation) Value() (r string, exists bool) {
	v := m._Value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "Value" field's value of the DbUserMetaData entity.
// If the DbUserMetaData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DbUserMetaDataMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "Value" field.
func (m *DbUserMetaDataMutation) ResetValue() {
	m._Value = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DbUserMetaDataMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DbUserMetaDataMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DbUserMetaDataMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DbUserMetaDataMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetUserID sets the "user" edge to the DbUser entity by id.
func (m *DbUserMetaDataMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the DbUser entity.
func (m *DbUserMetaDataMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the DbUser entity was cleared.
func (m *DbUserMetaDataMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *DbUserMetaDataMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *DbUserMetaDataMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *DbUserMetaDataMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the DbUserMetaDataMutation builder.
func (m *DbUserMetaDataMutation) Where(ps ...predicate.DbUserMetaData) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DbUserMetaDataMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DbUserMetaData).
func (m *DbUserMetaDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DbUserMetaDataMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tenant != nil {
		fields = append(fields, dbusermetadata.FieldTenantID)
	}
	if m._Name != nil {
		fields = append(fields, dbusermetadata.FieldName)
	}
	if m._Value != nil {
		fields = append(fields, dbusermetadata.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DbUserMetaDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dbusermetadata.FieldTenantID:
		return m.TenantID()
	case dbusermetadata.FieldName:
		return m.Name()
	case dbusermetadata.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DbUserMetaDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dbusermetadata.FieldTenantID:
		return m.OldTenantID(ctx)
	case dbusermetadata.FieldName:
		return m.OldName(ctx)
	case dbusermetadata.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown DbUserMetaData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DbUserMetaDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dbusermetadata.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case dbusermetadata.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dbusermetadata.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown DbUserMetaData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DbUserMetaDataMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DbUserMetaDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DbUserMetaDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DbUserMetaData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DbUserMetaDataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DbUserMetaDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DbUserMetaDataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DbUserMetaData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DbUserMetaDataMutation) ResetField(name string) error {
	switch name {
	case dbusermetadata.FieldTenantID:
		m.ResetTenantID()
		return nil
	case dbusermetadata.FieldName:
		m.ResetName()
		return nil
	case dbusermetadata.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown DbUserMetaData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DbUserMetaDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, dbusermetadata.EdgeTenant)
	}
	if m.user != nil {
		edges = append(edges, dbusermetadata.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DbUserMetaDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dbusermetadata.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case dbusermetadata.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DbUserMetaDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DbUserMetaDataMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DbUserMetaDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, dbusermetadata.EdgeTenant)
	}
	if m.cleareduser {
		edges = append(edges, dbusermetadata.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DbUserMetaDataMutation) EdgeCleared(name string) bool {
	switch name {
	case dbusermetadata.EdgeTenant:
		return m.clearedtenant
	case dbusermetadata.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DbUserMetaDataMutation) ClearEdge(name string) error {
	switch name {
	case dbusermetadata.EdgeTenant:
		m.ClearTenant()
		return nil
	case dbusermetadata.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown DbUserMetaData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DbUserMetaDataMutation) ResetEdge(name string) error {
	switch name {
	case dbusermetadata.EdgeTenant:
		m.ResetTenant()
		return nil
	case dbusermetadata.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown DbUserMetaData edge %s", name)
}

// TenantMutation represents an operation that mutates the Tenant nodes in the graph.
type TenantMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Tenant, error)
	predicates    []predicate.Tenant
}

var _ ent.Mutation = (*TenantMutation)(nil)

// tenantOption allows management of the mutation configuration using functional options.
type tenantOption func(*TenantMutation)

// newTenantMutation creates new mutation for the Tenant entity.
func newTenantMutation(c config, op Op, opts ...tenantOption) *TenantMutation {
	m := &TenantMutation{
		config:        c,
		op:            op,
		typ:           TypeTenant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantID sets the ID field of the mutation.
func withTenantID(id int) tenantOption {
	return func(m *TenantMutation) {
		var (
			err   error
			once  sync.Once
			value *Tenant
		)
		m.oldValue = func(ctx context.Context) (*Tenant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tenant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenant sets the old Tenant of the mutation.
func withTenant(node *Tenant) tenantOption {
	return func(m *TenantMutation) {
		m.oldValue = func(context.Context) (*Tenant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tenant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TenantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TenantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TenantMutation) ResetName() {
	m.name = nil
}

// Where appends a list predicates to the TenantMutation builder.
func (m *TenantMutation) Where(ps ...predicate.Tenant) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TenantMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tenant).
func (m *TenantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, tenant.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenant.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Tenant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tenant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tenant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantMutation) ResetField(name string) error {
	switch name {
	case tenant.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Tenant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Tenant edge %s", name)
}
